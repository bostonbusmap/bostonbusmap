// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tools/gtfs-realtime.proto

package com.google.transit.realtime;

public final class GtfsRealtime {
  private GtfsRealtime() {}
  public static void registerAllExtensions(
          com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface FeedMessageOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.FeedMessage)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  FeedMessage, FeedMessage.Builder> {

    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    boolean hasHeader();
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader();

    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity>
    getEntityList();
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index);
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    int getEntityCount();
  }
  /**
   * <pre>
   * The contents of a feed message.
   * A feed is a continuous stream of feed messages. Each message in the stream is
   * obtained as a response to an appropriate HTTP GET request.
   * A realtime feed is always defined with relation to an existing GTFS feed.
   * All the entity ids are resolved with respect to the GTFS feed.
   * A feed depends on some external configuration:
   * - The corresponding GTFS feed.
   * - Feed application (updates, positions or alerts). A feed should contain only
   *   items of one specified application; all the other entities will be ignored.
   * - Polling frequency
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedMessage}
   */
  public  static final class FeedMessage extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  FeedMessage, FeedMessage.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.FeedMessage)
          FeedMessageOrBuilder {
    private FeedMessage() {
      entity_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int HEADER_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.FeedHeader header_;
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    public boolean hasHeader() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader() {
      return header_ == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance() : header_;
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    private void setHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
      if (value == null) {
        throw new NullPointerException();
      }
      header_ = value;
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    private void setHeader(
            com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder builderForValue) {
      header_ = builderForValue.build();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    private void mergeHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
      if (header_ != null &&
              header_ != com.google.transit.realtime.GtfsRealtime.FeedHeader.getDefaultInstance()) {
        header_ =
                com.google.transit.realtime.GtfsRealtime.FeedHeader.newBuilder(header_).mergeFrom(value).buildPartial();
      } else {
        header_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * Metadata about this feed and feed message.
     * </pre>
     *
     * <code>required .transit_realtime.FeedHeader header = 1;</code>
     */
    private void clearHeader() {  header_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int ENTITY_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.transit.realtime.GtfsRealtime.FeedEntity> entity_;
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    public java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> getEntityList() {
      return entity_;
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder>
    getEntityOrBuilderList() {
      return entity_;
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    public int getEntityCount() {
      return entity_.size();
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index) {
      return entity_.get(index);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder getEntityOrBuilder(
            int index) {
      return entity_.get(index);
    }
    private void ensureEntityIsMutable() {
      if (!entity_.isModifiable()) {
        entity_ =
                com.google.protobuf.GeneratedMessageLite.mutableCopy(entity_);
      }
    }

    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void setEntity(
            int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureEntityIsMutable();
      entity_.set(index, value);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void setEntity(
            int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
      ensureEntityIsMutable();
      entity_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void addEntity(com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureEntityIsMutable();
      entity_.add(value);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void addEntity(
            int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureEntityIsMutable();
      entity_.add(index, value);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void addEntity(
            com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
      ensureEntityIsMutable();
      entity_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void addEntity(
            int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
      ensureEntityIsMutable();
      entity_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void addAllEntity(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.FeedEntity> values) {
      ensureEntityIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
              values, entity_);
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void clearEntity() {
      entity_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Contents of the feed.
     * </pre>
     *
     * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
     */
    private void removeEntity(int index) {
      ensureEntityIsMutable();
      entity_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.FeedMessage, com.google.transit.realtime.GtfsRealtime.FeedMessage.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getHeader());
      }
      for (int i = 0; i < entity_.size(); i++) {
        output.writeMessage(2, entity_.get(i));
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, getHeader());
      }
      for (int i = 0; i < entity_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(2, entity_.get(i));
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedMessage parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedMessage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The contents of a feed message.
     * A feed is a continuous stream of feed messages. Each message in the stream is
     * obtained as a response to an appropriate HTTP GET request.
     * A realtime feed is always defined with relation to an existing GTFS feed.
     * All the entity ids are resolved with respect to the GTFS feed.
     * A feed depends on some external configuration:
     * - The corresponding GTFS feed.
     * - Feed application (updates, positions or alerts). A feed should contain only
     *   items of one specified application; all the other entities will be ignored.
     * - Polling frequency
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedMessage}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.FeedMessage, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.FeedMessage)
            com.google.transit.realtime.GtfsRealtime.FeedMessageOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.FeedMessage.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public boolean hasHeader() {
        return instance.hasHeader();
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedHeader getHeader() {
        return instance.getHeader();
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder setHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
        copyOnWrite();
        instance.setHeader(value);
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder setHeader(
              com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder builderForValue) {
        copyOnWrite();
        instance.setHeader(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder mergeHeader(com.google.transit.realtime.GtfsRealtime.FeedHeader value) {
        copyOnWrite();
        instance.mergeHeader(value);
        return this;
      }
      /**
       * <pre>
       * Metadata about this feed and feed message.
       * </pre>
       *
       * <code>required .transit_realtime.FeedHeader header = 1;</code>
       */
      public Builder clearHeader() {  copyOnWrite();
        instance.clearHeader();
        return this;
      }

      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.FeedEntity> getEntityList() {
        return java.util.Collections.unmodifiableList(
                instance.getEntityList());
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public int getEntityCount() {
        return instance.getEntityCount();
      }/**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedEntity getEntity(int index) {
        return instance.getEntity(index);
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder setEntity(
              int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        copyOnWrite();
        instance.setEntity(index, value);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder setEntity(
              int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        copyOnWrite();
        instance.setEntity(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        copyOnWrite();
        instance.addEntity(value);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
              int index, com.google.transit.realtime.GtfsRealtime.FeedEntity value) {
        copyOnWrite();
        instance.addEntity(index, value);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
              com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        copyOnWrite();
        instance.addEntity(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addEntity(
              int index, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder builderForValue) {
        copyOnWrite();
        instance.addEntity(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder addAllEntity(
              java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.FeedEntity> values) {
        copyOnWrite();
        instance.addAllEntity(values);
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder clearEntity() {
        copyOnWrite();
        instance.clearEntity();
        return this;
      }
      /**
       * <pre>
       * Contents of the feed.
       * </pre>
       *
       * <code>repeated .transit_realtime.FeedEntity entity = 2;</code>
       */
      public Builder removeEntity(int index) {
        copyOnWrite();
        instance.removeEntity(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedMessage)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.FeedMessage();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasHeader()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!getHeader().isInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          for (int i = 0; i < getEntityCount(); i++) {
            if (!getEntity(i).isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          entity_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.FeedMessage other = (com.google.transit.realtime.GtfsRealtime.FeedMessage) arg1;
          header_ = visitor.visitMessage(header_, other.header_);
          entity_= visitor.visitList(entity_, other.entity_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000001) == 0x00000001)) {
                    subBuilder = header_.toBuilder();
                  }
                  header_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.FeedHeader.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(header_);
                    header_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000001;
                  break;
                }
                case 18: {
                  if (!entity_.isModifiable()) {
                    entity_ =
                            com.google.protobuf.GeneratedMessageLite.mutableCopy(entity_);
                  }
                  entity_.add(
                          input.readMessage(com.google.transit.realtime.GtfsRealtime.FeedEntity.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.FeedMessage.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
    private static final com.google.transit.realtime.GtfsRealtime.FeedMessage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new FeedMessage();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeedMessage> PARSER;

    public static com.google.protobuf.Parser<FeedMessage> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeedHeaderOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.FeedHeader)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  FeedHeader, FeedHeader.Builder> {

    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    boolean hasGtfsRealtimeVersion();
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    java.lang.String getGtfsRealtimeVersion();
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    com.google.protobuf.ByteString
    getGtfsRealtimeVersionBytes();

    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    boolean hasIncrementality();
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality();

    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    long getTimestamp();
  }
  /**
   * <pre>
   * Metadata about a feed, included in feed messages.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedHeader}
   */
  public  static final class FeedHeader extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  FeedHeader, FeedHeader.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.FeedHeader)
          FeedHeaderOrBuilder {
    private FeedHeader() {
      gtfsRealtimeVersion_ = "";
    }
    /**
     * <pre>
     * Determines whether the current fetch is incremental.  Currently,
     * DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
     * that use this mode.  There are discussions on the GTFS-realtime mailing
     * list around fully specifying the behavior of DIFFERENTIAL mode and the
     * documentation will be updated when those discussions are finalized.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.FeedHeader.Incrementality}
     */
    public enum Incrementality
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>FULL_DATASET = 0;</code>
       */
      FULL_DATASET(0),
      /**
       * <code>DIFFERENTIAL = 1;</code>
       */
      DIFFERENTIAL(1),
      ;

      /**
       * <code>FULL_DATASET = 0;</code>
       */
      public static final int FULL_DATASET_VALUE = 0;
      /**
       * <code>DIFFERENTIAL = 1;</code>
       */
      public static final int DIFFERENTIAL_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Incrementality valueOf(int value) {
        return forNumber(value);
      }

      public static Incrementality forNumber(int value) {
        switch (value) {
          case 0: return FULL_DATASET;
          case 1: return DIFFERENTIAL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Incrementality>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              Incrementality> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Incrementality>() {
                public Incrementality findValueByNumber(int number) {
                  return Incrementality.forNumber(number);
                }
              };

      private final int value;

      private Incrementality(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.FeedHeader.Incrementality)
    }

    private int bitField0_;
    public static final int GTFS_REALTIME_VERSION_FIELD_NUMBER = 1;
    private java.lang.String gtfsRealtimeVersion_;
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    public boolean hasGtfsRealtimeVersion() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    public java.lang.String getGtfsRealtimeVersion() {
      return gtfsRealtimeVersion_;
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    public com.google.protobuf.ByteString
    getGtfsRealtimeVersionBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(gtfsRealtimeVersion_);
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    private void setGtfsRealtimeVersion(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      gtfsRealtimeVersion_ = value;
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    private void clearGtfsRealtimeVersion() {
      bitField0_ = (bitField0_ & ~0x00000001);
      gtfsRealtimeVersion_ = getDefaultInstance().getGtfsRealtimeVersion();
    }
    /**
     * <pre>
     * Version of the feed specification.
     * The current version is 1.0.
     * </pre>
     *
     * <code>required string gtfs_realtime_version = 1;</code>
     */
    private void setGtfsRealtimeVersionBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      gtfsRealtimeVersion_ = value.toStringUtf8();
    }

    public static final int INCREMENTALITY_FIELD_NUMBER = 2;
    private int incrementality_;
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    public boolean hasIncrementality() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    public com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality() {
      com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality result = com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.forNumber(incrementality_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.FULL_DATASET : result;
    }
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    private void setIncrementality(com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      incrementality_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
     */
    private void clearIncrementality() {
      bitField0_ = (bitField0_ & ~0x00000002);
      incrementality_ = 0;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 3;
    private long timestamp_;
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    private void setTimestamp(long value) {
      bitField0_ |= 0x00000004;
      timestamp_ = value;
    }
    /**
     * <pre>
     * This timestamp identifies the moment when the content of this feed has been
     * created (in server time). In POSIX time (i.e., number of seconds since
     * January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 3;</code>
     */
    private void clearTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000004);
      timestamp_ = 0L;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.FeedHeader, com.google.transit.realtime.GtfsRealtime.FeedHeader.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getGtfsRealtimeVersion());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeEnum(2, incrementality_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, timestamp_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(1, getGtfsRealtimeVersion());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(2, incrementality_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt64Size(3, timestamp_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedHeader parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedHeader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Metadata about a feed, included in feed messages.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedHeader}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.FeedHeader, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.FeedHeader)
            com.google.transit.realtime.GtfsRealtime.FeedHeaderOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.FeedHeader.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public boolean hasGtfsRealtimeVersion() {
        return instance.hasGtfsRealtimeVersion();
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public java.lang.String getGtfsRealtimeVersion() {
        return instance.getGtfsRealtimeVersion();
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public com.google.protobuf.ByteString
      getGtfsRealtimeVersionBytes() {
        return instance.getGtfsRealtimeVersionBytes();
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public Builder setGtfsRealtimeVersion(
              java.lang.String value) {
        copyOnWrite();
        instance.setGtfsRealtimeVersion(value);
        return this;
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public Builder clearGtfsRealtimeVersion() {
        copyOnWrite();
        instance.clearGtfsRealtimeVersion();
        return this;
      }
      /**
       * <pre>
       * Version of the feed specification.
       * The current version is 1.0.
       * </pre>
       *
       * <code>required string gtfs_realtime_version = 1;</code>
       */
      public Builder setGtfsRealtimeVersionBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setGtfsRealtimeVersionBytes(value);
        return this;
      }

      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       */
      public boolean hasIncrementality() {
        return instance.hasIncrementality();
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       */
      public com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality getIncrementality() {
        return instance.getIncrementality();
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       */
      public Builder setIncrementality(com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality value) {
        copyOnWrite();
        instance.setIncrementality(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];</code>
       */
      public Builder clearIncrementality() {
        copyOnWrite();
        instance.clearIncrementality();
        return this;
      }

      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       */
      public boolean hasTimestamp() {
        return instance.hasTimestamp();
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       */
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * This timestamp identifies the moment when the content of this feed has been
       * created (in server time). In POSIX time (i.e., number of seconds since
       * January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 3;</code>
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedHeader)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.FeedHeader();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasGtfsRealtimeVersion()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.FeedHeader other = (com.google.transit.realtime.GtfsRealtime.FeedHeader) arg1;
          gtfsRealtimeVersion_ = visitor.visitString(
                  hasGtfsRealtimeVersion(), gtfsRealtimeVersion_,
                  other.hasGtfsRealtimeVersion(), other.gtfsRealtimeVersion_);
          incrementality_ = visitor.visitInt(hasIncrementality(), incrementality_,
                  other.hasIncrementality(), other.incrementality_);
          timestamp_ = visitor.visitLong(
                  hasTimestamp(), timestamp_,
                  other.hasTimestamp(), other.timestamp_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  gtfsRealtimeVersion_ = s;
                  break;
                }
                case 16: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality value = com.google.transit.realtime.GtfsRealtime.FeedHeader.Incrementality.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(2, rawValue);
                  } else {
                    bitField0_ |= 0x00000002;
                    incrementality_ = rawValue;
                  }
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000004;
                  timestamp_ = input.readUInt64();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.FeedHeader.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
    private static final com.google.transit.realtime.GtfsRealtime.FeedHeader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new FeedHeader();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedHeader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeedHeader> PARSER;

    public static com.google.protobuf.Parser<FeedHeader> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface FeedEntityOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.FeedEntity)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  FeedEntity, FeedEntity.Builder> {

    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    boolean hasId();
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    java.lang.String getId();
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    com.google.protobuf.ByteString
    getIdBytes();

    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    boolean hasIsDeleted();
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    boolean getIsDeleted();

    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    boolean hasTripUpdate();
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate();

    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    boolean hasVehicle();
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle();

    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    boolean hasAlert();
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.Alert getAlert();
  }
  /**
   * <pre>
   * A definition (or update) of an entity in the transit feed.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.FeedEntity}
   */
  public  static final class FeedEntity extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  FeedEntity, FeedEntity.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.FeedEntity)
          FeedEntityOrBuilder {
    private FeedEntity() {
      id_ = "";
    }
    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private java.lang.String id_;
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    public java.lang.String getId() {
      return id_;
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    public com.google.protobuf.ByteString
    getIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(id_);
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    private void setId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      id_ = value;
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      id_ = getDefaultInstance().getId();
    }
    /**
     * <pre>
     * The ids are used only to provide incrementality support. The id should be
     * unique within a FeedMessage. Consequent FeedMessages may contain
     * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
     * FeedEntity with some id will replace the old FeedEntity with the same id
     * (or delete it - see is_deleted below).
     * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
     * feed must be specified by explicit selectors (see EntitySelector below for
     * more info).
     * </pre>
     *
     * <code>required string id = 1;</code>
     */
    private void setIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      id_ = value.toStringUtf8();
    }

    public static final int IS_DELETED_FIELD_NUMBER = 2;
    private boolean isDeleted_;
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    public boolean hasIsDeleted() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    public boolean getIsDeleted() {
      return isDeleted_;
    }
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    private void setIsDeleted(boolean value) {
      bitField0_ |= 0x00000002;
      isDeleted_ = value;
    }
    /**
     * <pre>
     * Whether this entity is to be deleted. Relevant only for incremental
     * fetches.
     * </pre>
     *
     * <code>optional bool is_deleted = 2 [default = false];</code>
     */
    private void clearIsDeleted() {
      bitField0_ = (bitField0_ & ~0x00000002);
      isDeleted_ = false;
    }

    public static final int TRIP_UPDATE_FIELD_NUMBER = 3;
    private com.google.transit.realtime.GtfsRealtime.TripUpdate tripUpdate_;
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    public boolean hasTripUpdate() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate() {
      return tripUpdate_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance() : tripUpdate_;
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    private void setTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
      if (value == null) {
        throw new NullPointerException();
      }
      tripUpdate_ = value;
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    private void setTripUpdate(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder builderForValue) {
      tripUpdate_ = builderForValue.build();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    private void mergeTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
      if (tripUpdate_ != null &&
              tripUpdate_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.getDefaultInstance()) {
        tripUpdate_ =
                com.google.transit.realtime.GtfsRealtime.TripUpdate.newBuilder(tripUpdate_).mergeFrom(value).buildPartial();
      } else {
        tripUpdate_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Data about the entity itself. Exactly one of the following fields must be
     * present (unless the entity is being deleted).
     * </pre>
     *
     * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
     */
    private void clearTripUpdate() {  tripUpdate_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int VEHICLE_FIELD_NUMBER = 4;
    private com.google.transit.realtime.GtfsRealtime.VehiclePosition vehicle_;
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance() : vehicle_;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    private void setVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
      if (value == null) {
        throw new NullPointerException();
      }
      vehicle_ = value;
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    private void setVehicle(
            com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder builderForValue) {
      vehicle_ = builderForValue.build();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    private void mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
      if (vehicle_ != null &&
              vehicle_ != com.google.transit.realtime.GtfsRealtime.VehiclePosition.getDefaultInstance()) {
        vehicle_ =
                com.google.transit.realtime.GtfsRealtime.VehiclePosition.newBuilder(vehicle_).mergeFrom(value).buildPartial();
      } else {
        vehicle_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
     */
    private void clearVehicle() {  vehicle_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int ALERT_FIELD_NUMBER = 5;
    private com.google.transit.realtime.GtfsRealtime.Alert alert_;
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    public boolean hasAlert() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.Alert getAlert() {
      return alert_ == null ? com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance() : alert_;
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    private void setAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
      if (value == null) {
        throw new NullPointerException();
      }
      alert_ = value;
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    private void setAlert(
            com.google.transit.realtime.GtfsRealtime.Alert.Builder builderForValue) {
      alert_ = builderForValue.build();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    private void mergeAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
      if (alert_ != null &&
              alert_ != com.google.transit.realtime.GtfsRealtime.Alert.getDefaultInstance()) {
        alert_ =
                com.google.transit.realtime.GtfsRealtime.Alert.newBuilder(alert_).mergeFrom(value).buildPartial();
      } else {
        alert_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .transit_realtime.Alert alert = 5;</code>
     */
    private void clearAlert() {  alert_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.FeedEntity, com.google.transit.realtime.GtfsRealtime.FeedEntity.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBool(2, isDeleted_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getTripUpdate());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, getVehicle());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getAlert());
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(1, getId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeBoolSize(2, isDeleted_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(3, getTripUpdate());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(4, getVehicle());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(5, getAlert());
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.FeedEntity parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.FeedEntity prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A definition (or update) of an entity in the transit feed.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.FeedEntity}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.FeedEntity, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.FeedEntity)
            com.google.transit.realtime.GtfsRealtime.FeedEntityOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.FeedEntity.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public java.lang.String getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public com.google.protobuf.ByteString
      getIdBytes() {
        return instance.getIdBytes();
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public Builder setId(
              java.lang.String value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }
      /**
       * <pre>
       * The ids are used only to provide incrementality support. The id should be
       * unique within a FeedMessage. Consequent FeedMessages may contain
       * FeedEntities with the same id. In case of a DIFFERENTIAL update the new
       * FeedEntity with some id will replace the old FeedEntity with the same id
       * (or delete it - see is_deleted below).
       * The actual GTFS entities (e.g. stations, routes, trips) referenced by the
       * feed must be specified by explicit selectors (see EntitySelector below for
       * more info).
       * </pre>
       *
       * <code>required string id = 1;</code>
       */
      public Builder setIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       */
      public boolean hasIsDeleted() {
        return instance.hasIsDeleted();
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       */
      public boolean getIsDeleted() {
        return instance.getIsDeleted();
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       */
      public Builder setIsDeleted(boolean value) {
        copyOnWrite();
        instance.setIsDeleted(value);
        return this;
      }
      /**
       * <pre>
       * Whether this entity is to be deleted. Relevant only for incremental
       * fetches.
       * </pre>
       *
       * <code>optional bool is_deleted = 2 [default = false];</code>
       */
      public Builder clearIsDeleted() {
        copyOnWrite();
        instance.clearIsDeleted();
        return this;
      }

      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public boolean hasTripUpdate() {
        return instance.hasTripUpdate();
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate getTripUpdate() {
        return instance.getTripUpdate();
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder setTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
        copyOnWrite();
        instance.setTripUpdate(value);
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder setTripUpdate(
              com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setTripUpdate(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder mergeTripUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate value) {
        copyOnWrite();
        instance.mergeTripUpdate(value);
        return this;
      }
      /**
       * <pre>
       * Data about the entity itself. Exactly one of the following fields must be
       * present (unless the entity is being deleted).
       * </pre>
       *
       * <code>optional .transit_realtime.TripUpdate trip_update = 3;</code>
       */
      public Builder clearTripUpdate() {  copyOnWrite();
        instance.clearTripUpdate();
        return this;
      }

      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public boolean hasVehicle() {
        return instance.hasVehicle();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition getVehicle() {
        return instance.getVehicle();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
        copyOnWrite();
        instance.setVehicle(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder setVehicle(
              com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder builderForValue) {
        copyOnWrite();
        instance.setVehicle(builderForValue);
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehiclePosition value) {
        copyOnWrite();
        instance.mergeVehicle(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition vehicle = 4;</code>
       */
      public Builder clearVehicle() {  copyOnWrite();
        instance.clearVehicle();
        return this;
      }

      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public boolean hasAlert() {
        return instance.hasAlert();
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Alert getAlert() {
        return instance.getAlert();
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder setAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
        copyOnWrite();
        instance.setAlert(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder setAlert(
              com.google.transit.realtime.GtfsRealtime.Alert.Builder builderForValue) {
        copyOnWrite();
        instance.setAlert(builderForValue);
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder mergeAlert(com.google.transit.realtime.GtfsRealtime.Alert value) {
        copyOnWrite();
        instance.mergeAlert(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert alert = 5;</code>
       */
      public Builder clearAlert() {  copyOnWrite();
        instance.clearAlert();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.FeedEntity)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.FeedEntity();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasId()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (hasTripUpdate()) {
            if (!getTripUpdate().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasVehicle()) {
            if (!getVehicle().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasAlert()) {
            if (!getAlert().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.FeedEntity other = (com.google.transit.realtime.GtfsRealtime.FeedEntity) arg1;
          id_ = visitor.visitString(
                  hasId(), id_,
                  other.hasId(), other.id_);
          isDeleted_ = visitor.visitBoolean(
                  hasIsDeleted(), isDeleted_,
                  other.hasIsDeleted(), other.isDeleted_);
          tripUpdate_ = visitor.visitMessage(tripUpdate_, other.tripUpdate_);
          vehicle_ = visitor.visitMessage(vehicle_, other.vehicle_);
          alert_ = visitor.visitMessage(alert_, other.alert_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  id_ = s;
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000002;
                  isDeleted_ = input.readBool();
                  break;
                }
                case 26: {
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000004) == 0x00000004)) {
                    subBuilder = tripUpdate_.toBuilder();
                  }
                  tripUpdate_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripUpdate.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(tripUpdate_);
                    tripUpdate_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000004;
                  break;
                }
                case 34: {
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000008) == 0x00000008)) {
                    subBuilder = vehicle_.toBuilder();
                  }
                  vehicle_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.VehiclePosition.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(vehicle_);
                    vehicle_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000008;
                  break;
                }
                case 42: {
                  com.google.transit.realtime.GtfsRealtime.Alert.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000010) == 0x00000010)) {
                    subBuilder = alert_.toBuilder();
                  }
                  alert_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.Alert.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(alert_);
                    alert_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000010;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.FeedEntity.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
    private static final com.google.transit.realtime.GtfsRealtime.FeedEntity DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new FeedEntity();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.FeedEntity getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<FeedEntity> PARSER;

    public static com.google.protobuf.Parser<FeedEntity> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TripUpdateOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  TripUpdate, TripUpdate.Builder> {

    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    boolean hasTrip();
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();

    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    boolean hasVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle();

    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate>
    getStopTimeUpdateList();
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index);
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    int getStopTimeUpdateCount();

    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    long getTimestamp();

    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    boolean hasDelay();
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    int getDelay();
  }
  /**
   * <pre>
   * Realtime update of the progress of a vehicle along a trip.
   * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
   * - A trip that proceeds along the schedule.
   * - A trip that proceeds along a route but has no fixed schedule.
   * - A trip that have been added or removed with regard to schedule.
   * The updates can be for future, predicted arrival/departure events, or for
   * past events that already occurred.
   * Normally, updates should get more precise and more certain (see
   * uncertainty below) as the events gets closer to current time.
   * Even if that is not possible, the information for past events should be
   * precise and certain. In particular, if an update points to time in the past
   * but its update's uncertainty is not 0, the client should conclude that the
   * update is a (wrong) prediction and that the trip has not completed yet.
   * Note that the update can describe a trip that is already completed.
   * To this end, it is enough to provide an update for the last stop of the trip.
   * If the time of that is in the past, the client will conclude from that that
   * the whole trip is in the past (it is possible, although inconsequential, to
   * also provide updates for preceding stops).
   * This option is most relevant for a trip that has completed ahead of schedule,
   * but according to the schedule, the trip is still proceeding at the current
   * time. Removing the updates for this trip could make the client assume
   * that the trip is still proceeding.
   * Note that the feed provider is allowed, but not required, to purge past
   * updates - this is one case where this would be practically useful.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TripUpdate}
   */
  public  static final class TripUpdate extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  TripUpdate, TripUpdate.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate)
          TripUpdateOrBuilder {
    private TripUpdate() {
      stopTimeUpdate_ = emptyProtobufList();
    }
    public interface StopTimeEventOrBuilder extends
            // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.StopTimeEvent)
            com.google.protobuf.GeneratedMessageLite.
                    ExtendableMessageOrBuilder<
                    StopTimeEvent, StopTimeEvent.Builder> {

      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      boolean hasDelay();
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      int getDelay();

      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      boolean hasTime();
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      long getTime();

      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      boolean hasUncertainty();
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      int getUncertainty();
    }
    /**
     * <pre>
     * Timing information for a single predicted event (either arrival or
     * departure).
     * Timing consists of delay and/or estimated time, and uncertainty.
     * - delay should be used when the prediction is given relative to some
     *   existing schedule in GTFS.
     * - time should be given whether there is a predicted schedule or not. If
     *   both time and delay are specified, time will take precedence
     *   (although normally, time, if given for a scheduled trip, should be
     *   equal to scheduled time in GTFS + delay).
     * Uncertainty applies equally to both time and delay.
     * The uncertainty roughly specifies the expected error in true delay (but
     * note, we don't yet define its precise statistical meaning). It's possible
     * for the uncertainty to be 0, for example for trains that are driven under
     * computer timing control.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate.StopTimeEvent}
     */
    public  static final class StopTimeEvent extends
            com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                    StopTimeEvent, StopTimeEvent.Builder> implements
            // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.StopTimeEvent)
            StopTimeEventOrBuilder {
      private StopTimeEvent() {
      }
      private int bitField0_;
      public static final int DELAY_FIELD_NUMBER = 1;
      private int delay_;
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      public boolean hasDelay() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      public int getDelay() {
        return delay_;
      }
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      private void setDelay(int value) {
        bitField0_ |= 0x00000001;
        delay_ = value;
      }
      /**
       * <pre>
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * </pre>
       *
       * <code>optional int32 delay = 1;</code>
       */
      private void clearDelay() {
        bitField0_ = (bitField0_ & ~0x00000001);
        delay_ = 0;
      }

      public static final int TIME_FIELD_NUMBER = 2;
      private long time_;
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      public boolean hasTime() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      public long getTime() {
        return time_;
      }
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      private void setTime(long value) {
        bitField0_ |= 0x00000002;
        time_ = value;
      }
      /**
       * <pre>
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       * </pre>
       *
       * <code>optional int64 time = 2;</code>
       */
      private void clearTime() {
        bitField0_ = (bitField0_ & ~0x00000002);
        time_ = 0L;
      }

      public static final int UNCERTAINTY_FIELD_NUMBER = 3;
      private int uncertainty_;
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      public boolean hasUncertainty() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      public int getUncertainty() {
        return uncertainty_;
      }
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      private void setUncertainty(int value) {
        bitField0_ |= 0x00000004;
        uncertainty_ = value;
      }
      /**
       * <pre>
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       * </pre>
       *
       * <code>optional int32 uncertainty = 3;</code>
       */
      private void clearUncertainty() {
        bitField0_ = (bitField0_ & ~0x00000004);
        uncertainty_ = 0;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
              throws java.io.IOException {
        com.google.protobuf.GeneratedMessageLite
                .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder>
                .ExtensionWriter extensionWriter =
                newExtensionWriter();
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeInt32(1, delay_);
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          output.writeInt64(2, time_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          output.writeInt32(3, uncertainty_);
        }
        extensionWriter.writeUntil(2000, output);
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeInt32Size(1, delay_);
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeInt64Size(2, time_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeInt32Size(3, uncertainty_);
        }
        size += extensionsSerializedSize();
        size += unknownFields.getSerializedSize();
        memoizedSerializedSize = size;
        return size;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(byte[] data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              byte[] data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(java.io.InputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseDelimitedFrom(java.io.InputStream input)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              com.google.protobuf.CodedInputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      /**
       * <pre>
       * Timing information for a single predicted event (either arrival or
       * departure).
       * Timing consists of delay and/or estimated time, and uncertainty.
       * - delay should be used when the prediction is given relative to some
       *   existing schedule in GTFS.
       * - time should be given whether there is a predicted schedule or not. If
       *   both time and delay are specified, time will take precedence
       *   (although normally, time, if given for a scheduled trip, should be
       *   equal to scheduled time in GTFS + delay).
       * Uncertainty applies equally to both time and delay.
       * The uncertainty roughly specifies the expected error in true delay (but
       * note, we don't yet define its precise statistical meaning). It's possible
       * for the uncertainty to be 0, for example for trains that are driven under
       * computer timing control.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.StopTimeEvent}
       */
      public static final class Builder extends
              com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent, Builder> implements
              // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.StopTimeEvent)
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEventOrBuilder {
        // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         */
        public boolean hasDelay() {
          return instance.hasDelay();
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         */
        public int getDelay() {
          return instance.getDelay();
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         */
        public Builder setDelay(int value) {
          copyOnWrite();
          instance.setDelay(value);
          return this;
        }
        /**
         * <pre>
         * Delay (in seconds) can be positive (meaning that the vehicle is late) or
         * negative (meaning that the vehicle is ahead of schedule). Delay of 0
         * means that the vehicle is exactly on time.
         * </pre>
         *
         * <code>optional int32 delay = 1;</code>
         */
        public Builder clearDelay() {
          copyOnWrite();
          instance.clearDelay();
          return this;
        }

        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         */
        public boolean hasTime() {
          return instance.hasTime();
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         */
        public long getTime() {
          return instance.getTime();
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         */
        public Builder setTime(long value) {
          copyOnWrite();
          instance.setTime(value);
          return this;
        }
        /**
         * <pre>
         * Event as absolute time.
         * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
         * UTC).
         * </pre>
         *
         * <code>optional int64 time = 2;</code>
         */
        public Builder clearTime() {
          copyOnWrite();
          instance.clearTime();
          return this;
        }

        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         */
        public boolean hasUncertainty() {
          return instance.hasUncertainty();
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         */
        public int getUncertainty() {
          return instance.getUncertainty();
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         */
        public Builder setUncertainty(int value) {
          copyOnWrite();
          instance.setUncertainty(value);
          return this;
        }
        /**
         * <pre>
         * If uncertainty is omitted, it is interpreted as unknown.
         * If the prediction is unknown or too uncertain, the delay (or time) field
         * should be empty. In such case, the uncertainty field is ignored.
         * To specify a completely certain prediction, set its uncertainty to 0.
         * </pre>
         *
         * <code>optional int32 uncertainty = 3;</code>
         */
        public Builder clearUncertainty() {
          copyOnWrite();
          instance.clearUncertainty();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.StopTimeEvent)
      }
      private byte memoizedIsInitialized = -1;
      protected final Object dynamicMethod(
              com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
              Object arg0, Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent();
          }
          case IS_INITIALIZED: {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return DEFAULT_INSTANCE;
            if (isInitialized == 0) return null;

            boolean shouldMemoize = ((Boolean) arg0).booleanValue();
            if (!extensionsAreInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
            if (shouldMemoize) memoizedIsInitialized = 1;
            return DEFAULT_INSTANCE;

          }
          case MAKE_IMMUTABLE: {
            return null;
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case VISIT: {
            Visitor visitor = (Visitor) arg0;
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent) arg1;
            delay_ = visitor.visitInt(
                    hasDelay(), delay_,
                    other.hasDelay(), other.delay_);
            time_ = visitor.visitLong(
                    hasTime(), time_,
                    other.hasTime(), other.time_);
            uncertainty_ = visitor.visitInt(
                    hasUncertainty(), uncertainty_,
                    other.hasUncertainty(), other.uncertainty_);
            if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                    .INSTANCE) {
              bitField0_ |= other.bitField0_;
            }
            return this;
          }
          case MERGE_FROM_STREAM: {
            com.google.protobuf.CodedInputStream input =
                    (com.google.protobuf.CodedInputStream) arg0;
            com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                    (com.google.protobuf.ExtensionRegistryLite) arg1;
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  default: {
                    if (!parseUnknownField(getDefaultInstanceForType(),
                            input, extensionRegistry, tag)) {
                      done = true;
                    }
                    break;
                  }
                  case 8: {
                    bitField0_ |= 0x00000001;
                    delay_ = input.readInt32();
                    break;
                  }
                  case 16: {
                    bitField0_ |= 0x00000002;
                    time_ = input.readInt64();
                    break;
                  }
                  case 24: {
                    bitField0_ |= 0x00000004;
                    uncertainty_ = input.readInt32();
                    break;
                  }
                }
              }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw new RuntimeException(e.setUnfinishedMessage(this));
            } catch (java.io.IOException e) {
              throw new RuntimeException(
                      new com.google.protobuf.InvalidProtocolBufferException(
                              e.getMessage()).setUnfinishedMessage(this));
            } finally {
            }
          }
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
            }
            return PARSER;
          }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
      private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new StopTimeEvent();
        DEFAULT_INSTANCE.makeImmutable();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<StopTimeEvent> PARSER;

      public static com.google.protobuf.Parser<StopTimeEvent> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public interface StopTimeUpdateOrBuilder extends
            // @@protoc_insertion_point(interface_extends:transit_realtime.TripUpdate.StopTimeUpdate)
            com.google.protobuf.GeneratedMessageLite.
                    ExtendableMessageOrBuilder<
                    StopTimeUpdate, StopTimeUpdate.Builder> {

      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      boolean hasStopSequence();
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      int getStopSequence();

      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      boolean hasStopId();
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      java.lang.String getStopId();
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      com.google.protobuf.ByteString
      getStopIdBytes();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      boolean hasArrival();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      boolean hasDeparture();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture();

      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      boolean hasScheduleRelationship();
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship();
    }
    /**
     * <pre>
     * Realtime update for arrival and/or departure events for a given stop on a
     * trip. Updates can be supplied for both past and future events.
     * The producer is allowed, although not required, to drop past events.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate}
     */
    public  static final class StopTimeUpdate extends
            com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                    StopTimeUpdate, StopTimeUpdate.Builder> implements
            // @@protoc_insertion_point(message_implements:transit_realtime.TripUpdate.StopTimeUpdate)
            StopTimeUpdateOrBuilder {
      private StopTimeUpdate() {
        stopId_ = "";
      }
      /**
       * <pre>
       * The relation between this StopTime and the static schedule.
       * </pre>
       *
       * Protobuf enum {@code transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship}
       */
      public enum ScheduleRelationship
              implements com.google.protobuf.Internal.EnumLite {
        /**
         * <pre>
         * The vehicle is proceeding in accordance with its static schedule of
         * stops, although not necessarily according to the times of the schedule.
         * At least one of arrival and departure must be provided. If the schedule
         * for this stop contains both arrival and departure times then so must
         * this update.
         * </pre>
         *
         * <code>SCHEDULED = 0;</code>
         */
        SCHEDULED(0),
        /**
         * <pre>
         * The stop is skipped, i.e., the vehicle will not stop at this stop.
         * Arrival and departure are optional.
         * </pre>
         *
         * <code>SKIPPED = 1;</code>
         */
        SKIPPED(1),
        /**
         * <pre>
         * No data is given for this stop. The main intention for this value is to
         * give the predictions only for part of a trip, i.e., if the last update
         * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
         * stops in the trip are considered to be unspecified as well.
         * Neither arrival nor departure should be supplied.
         * </pre>
         *
         * <code>NO_DATA = 2;</code>
         */
        NO_DATA(2),
        ;

        /**
         * <pre>
         * The vehicle is proceeding in accordance with its static schedule of
         * stops, although not necessarily according to the times of the schedule.
         * At least one of arrival and departure must be provided. If the schedule
         * for this stop contains both arrival and departure times then so must
         * this update.
         * </pre>
         *
         * <code>SCHEDULED = 0;</code>
         */
        public static final int SCHEDULED_VALUE = 0;
        /**
         * <pre>
         * The stop is skipped, i.e., the vehicle will not stop at this stop.
         * Arrival and departure are optional.
         * </pre>
         *
         * <code>SKIPPED = 1;</code>
         */
        public static final int SKIPPED_VALUE = 1;
        /**
         * <pre>
         * No data is given for this stop. The main intention for this value is to
         * give the predictions only for part of a trip, i.e., if the last update
         * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
         * stops in the trip are considered to be unspecified as well.
         * Neither arrival nor departure should be supplied.
         * </pre>
         *
         * <code>NO_DATA = 2;</code>
         */
        public static final int NO_DATA_VALUE = 2;


        public final int getNumber() {
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ScheduleRelationship valueOf(int value) {
          return forNumber(value);
        }

        public static ScheduleRelationship forNumber(int value) {
          switch (value) {
            case 0: return SCHEDULED;
            case 1: return SKIPPED;
            case 2: return NO_DATA;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>
        internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
                ScheduleRelationship> internalValueMap =
                new com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>() {
                  public ScheduleRelationship findValueByNumber(int number) {
                    return ScheduleRelationship.forNumber(number);
                  }
                };

        private final int value;

        private ScheduleRelationship(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship)
      }

      private int bitField0_;
      public static final int STOP_SEQUENCE_FIELD_NUMBER = 1;
      private int stopSequence_;
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      public boolean hasStopSequence() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      public int getStopSequence() {
        return stopSequence_;
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      private void setStopSequence(int value) {
        bitField0_ |= 0x00000001;
        stopSequence_ = value;
      }
      /**
       * <pre>
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional uint32 stop_sequence = 1;</code>
       */
      private void clearStopSequence() {
        bitField0_ = (bitField0_ & ~0x00000001);
        stopSequence_ = 0;
      }

      public static final int STOP_ID_FIELD_NUMBER = 4;
      private java.lang.String stopId_;
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      public boolean hasStopId() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      public java.lang.String getStopId() {
        return stopId_;
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      public com.google.protobuf.ByteString
      getStopIdBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(stopId_);
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      private void setStopId(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        stopId_ = value;
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      private void clearStopId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        stopId_ = getDefaultInstance().getStopId();
      }
      /**
       * <pre>
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 4;</code>
       */
      private void setStopIdBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        stopId_ = value.toStringUtf8();
      }

      public static final int ARRIVAL_FIELD_NUMBER = 2;
      private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent arrival_;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      public boolean hasArrival() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival() {
        return arrival_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : arrival_;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      private void setArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
        if (value == null) {
          throw new NullPointerException();
        }
        arrival_ = value;
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      private void setArrival(
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
        arrival_ = builderForValue.build();
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      private void mergeArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
        if (arrival_ != null &&
                arrival_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance()) {
          arrival_ =
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder(arrival_).mergeFrom(value).buildPartial();
        } else {
          arrival_ = value;
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
       */
      private void clearArrival() {  arrival_ = null;
        bitField0_ = (bitField0_ & ~0x00000004);
      }

      public static final int DEPARTURE_FIELD_NUMBER = 3;
      private com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent departure_;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      public boolean hasDeparture() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture() {
        return departure_ == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance() : departure_;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      private void setDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
        if (value == null) {
          throw new NullPointerException();
        }
        departure_ = value;
        bitField0_ |= 0x00000008;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      private void setDeparture(
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
        departure_ = builderForValue.build();
        bitField0_ |= 0x00000008;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      private void mergeDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
        if (departure_ != null &&
                departure_ != com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.getDefaultInstance()) {
          departure_ =
                  com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder(departure_).mergeFrom(value).buildPartial();
        } else {
          departure_ = value;
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
       */
      private void clearDeparture() {  departure_ = null;
        bitField0_ = (bitField0_ & ~0x00000008);
      }

      public static final int SCHEDULE_RELATIONSHIP_FIELD_NUMBER = 5;
      private int scheduleRelationship_;
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      public boolean hasScheduleRelationship() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship() {
        com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.forNumber(scheduleRelationship_);
        return result == null ? com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED : result;
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      private void setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000010;
        scheduleRelationship_ = value.getNumber();
      }
      /**
       * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
       */
      private void clearScheduleRelationship() {
        bitField0_ = (bitField0_ & ~0x00000010);
        scheduleRelationship_ = 0;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
              throws java.io.IOException {
        com.google.protobuf.GeneratedMessageLite
                .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder>
                .ExtensionWriter extensionWriter =
                newExtensionWriter();
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeUInt32(1, stopSequence_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          output.writeMessage(2, getArrival());
        }
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          output.writeMessage(3, getDeparture());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          output.writeString(4, getStopId());
        }
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          output.writeEnum(5, scheduleRelationship_);
        }
        extensionWriter.writeUntil(2000, output);
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeUInt32Size(1, stopSequence_);
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeMessageSize(2, getArrival());
        }
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeMessageSize(3, getDeparture());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeStringSize(4, getStopId());
        }
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeEnumSize(5, scheduleRelationship_);
        }
        size += extensionsSerializedSize();
        size += unknownFields.getSerializedSize();
        memoizedSerializedSize = size;
        return size;
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(byte[] data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              byte[] data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(java.io.InputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseDelimitedFrom(java.io.InputStream input)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              com.google.protobuf.CodedInputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      /**
       * <pre>
       * Realtime update for arrival and/or departure events for a given stop on a
       * trip. Updates can be supplied for both past and future events.
       * The producer is allowed, although not required, to drop past events.
       * </pre>
       *
       * Protobuf type {@code transit_realtime.TripUpdate.StopTimeUpdate}
       */
      public static final class Builder extends
              com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                      com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate, Builder> implements
              // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate.StopTimeUpdate)
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder {
        // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         */
        public boolean hasStopSequence() {
          return instance.hasStopSequence();
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         */
        public int getStopSequence() {
          return instance.getStopSequence();
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         */
        public Builder setStopSequence(int value) {
          copyOnWrite();
          instance.setStopSequence(value);
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stop_times.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional uint32 stop_sequence = 1;</code>
         */
        public Builder clearStopSequence() {
          copyOnWrite();
          instance.clearStopSequence();
          return this;
        }

        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public boolean hasStopId() {
          return instance.hasStopId();
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public java.lang.String getStopId() {
          return instance.getStopId();
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public com.google.protobuf.ByteString
        getStopIdBytes() {
          return instance.getStopIdBytes();
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public Builder setStopId(
                java.lang.String value) {
          copyOnWrite();
          instance.setStopId(value);
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public Builder clearStopId() {
          copyOnWrite();
          instance.clearStopId();
          return this;
        }
        /**
         * <pre>
         * Must be the same as in stops.txt in the corresponding GTFS feed.
         * </pre>
         *
         * <code>optional string stop_id = 4;</code>
         */
        public Builder setStopIdBytes(
                com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setStopIdBytes(value);
          return this;
        }

        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public boolean hasArrival() {
          return instance.hasArrival();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getArrival() {
          return instance.getArrival();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder setArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          copyOnWrite();
          instance.setArrival(value);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder setArrival(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
          copyOnWrite();
          instance.setArrival(builderForValue);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder mergeArrival(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          copyOnWrite();
          instance.mergeArrival(value);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;</code>
         */
        public Builder clearArrival() {  copyOnWrite();
          instance.clearArrival();
          return this;
        }

        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public boolean hasDeparture() {
          return instance.hasDeparture();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent getDeparture() {
          return instance.getDeparture();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder setDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          copyOnWrite();
          instance.setDeparture(value);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder setDeparture(
                com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder builderForValue) {
          copyOnWrite();
          instance.setDeparture(builderForValue);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder mergeDeparture(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent value) {
          copyOnWrite();
          instance.mergeDeparture(value);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;</code>
         */
        public Builder clearDeparture() {  copyOnWrite();
          instance.clearDeparture();
          return this;
        }

        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         */
        public boolean hasScheduleRelationship() {
          return instance.hasScheduleRelationship();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         */
        public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship getScheduleRelationship() {
          return instance.getScheduleRelationship();
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         */
        public Builder setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship value) {
          copyOnWrite();
          instance.setScheduleRelationship(value);
          return this;
        }
        /**
         * <code>optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];</code>
         */
        public Builder clearScheduleRelationship() {
          copyOnWrite();
          instance.clearScheduleRelationship();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate.StopTimeUpdate)
      }
      private byte memoizedIsInitialized = -1;
      protected final Object dynamicMethod(
              com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
              Object arg0, Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate();
          }
          case IS_INITIALIZED: {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return DEFAULT_INSTANCE;
            if (isInitialized == 0) return null;

            boolean shouldMemoize = ((Boolean) arg0).booleanValue();
            if (hasArrival()) {
              if (!getArrival().isInitialized()) {
                if (shouldMemoize) {
                  memoizedIsInitialized = 0;
                }
                return null;
              }
            }
            if (hasDeparture()) {
              if (!getDeparture().isInitialized()) {
                if (shouldMemoize) {
                  memoizedIsInitialized = 0;
                }
                return null;
              }
            }
            if (!extensionsAreInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
            if (shouldMemoize) memoizedIsInitialized = 1;
            return DEFAULT_INSTANCE;

          }
          case MAKE_IMMUTABLE: {
            return null;
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case VISIT: {
            Visitor visitor = (Visitor) arg0;
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate other = (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate) arg1;
            stopSequence_ = visitor.visitInt(
                    hasStopSequence(), stopSequence_,
                    other.hasStopSequence(), other.stopSequence_);
            stopId_ = visitor.visitString(
                    hasStopId(), stopId_,
                    other.hasStopId(), other.stopId_);
            arrival_ = visitor.visitMessage(arrival_, other.arrival_);
            departure_ = visitor.visitMessage(departure_, other.departure_);
            scheduleRelationship_ = visitor.visitInt(hasScheduleRelationship(), scheduleRelationship_,
                    other.hasScheduleRelationship(), other.scheduleRelationship_);
            if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                    .INSTANCE) {
              bitField0_ |= other.bitField0_;
            }
            return this;
          }
          case MERGE_FROM_STREAM: {
            com.google.protobuf.CodedInputStream input =
                    (com.google.protobuf.CodedInputStream) arg0;
            com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                    (com.google.protobuf.ExtensionRegistryLite) arg1;
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  default: {
                    if (!parseUnknownField(getDefaultInstanceForType(),
                            input, extensionRegistry, tag)) {
                      done = true;
                    }
                    break;
                  }
                  case 8: {
                    bitField0_ |= 0x00000001;
                    stopSequence_ = input.readUInt32();
                    break;
                  }
                  case 18: {
                    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder subBuilder = null;
                    if (((bitField0_ & 0x00000004) == 0x00000004)) {
                      subBuilder = arrival_.toBuilder();
                    }
                    arrival_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.parser(), extensionRegistry);
                    if (subBuilder != null) {
                      subBuilder.mergeFrom(arrival_);
                      arrival_ = subBuilder.buildPartial();
                    }
                    bitField0_ |= 0x00000004;
                    break;
                  }
                  case 26: {
                    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.Builder subBuilder = null;
                    if (((bitField0_ & 0x00000008) == 0x00000008)) {
                      subBuilder = departure_.toBuilder();
                    }
                    departure_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeEvent.parser(), extensionRegistry);
                    if (subBuilder != null) {
                      subBuilder.mergeFrom(departure_);
                      departure_ = subBuilder.buildPartial();
                    }
                    bitField0_ |= 0x00000008;
                    break;
                  }
                  case 34: {
                    String s = input.readString();
                    bitField0_ |= 0x00000002;
                    stopId_ = s;
                    break;
                  }
                  case 40: {
                    int rawValue = input.readEnum();
                    com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship value = com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.forNumber(rawValue);
                    if (value == null) {
                      super.mergeVarintField(5, rawValue);
                    } else {
                      bitField0_ |= 0x00000010;
                      scheduleRelationship_ = rawValue;
                    }
                    break;
                  }
                }
              }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw new RuntimeException(e.setUnfinishedMessage(this));
            } catch (java.io.IOException e) {
              throw new RuntimeException(
                      new com.google.protobuf.InvalidProtocolBufferException(
                              e.getMessage()).setUnfinishedMessage(this));
            } finally {
            }
          }
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
            }
            return PARSER;
          }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
      private static final com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new StopTimeUpdate();
        DEFAULT_INSTANCE.makeImmutable();
      }

      public static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<StopTimeUpdate> PARSER;

      public static com.google.protobuf.Parser<StopTimeUpdate> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    private int bitField0_;
    public static final int TRIP_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (value == null) {
        throw new NullPointerException();
      }
      trip_ = value;
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void setTrip(
            com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
      trip_ = builderForValue.build();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (trip_ != null &&
              trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
        trip_ =
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.newBuilder(trip_).mergeFrom(value).buildPartial();
      } else {
        trip_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     * </pre>
     *
     * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void clearTrip() {  trip_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int VEHICLE_FIELD_NUMBER = 3;
    private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    private void setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
      if (value == null) {
        throw new NullPointerException();
      }
      vehicle_ = value;
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    private void setVehicle(
            com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
      vehicle_ = builderForValue.build();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    private void mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
      if (vehicle_ != null &&
              vehicle_ != com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance()) {
        vehicle_ =
                com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.newBuilder(vehicle_).mergeFrom(value).buildPartial();
      } else {
        vehicle_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
     */
    private void clearVehicle() {  vehicle_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int STOP_TIME_UPDATE_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> stopTimeUpdate_;
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> getStopTimeUpdateList() {
      return stopTimeUpdate_;
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder>
    getStopTimeUpdateOrBuilderList() {
      return stopTimeUpdate_;
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    public int getStopTimeUpdateCount() {
      return stopTimeUpdate_.size();
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index) {
      return stopTimeUpdate_.get(index);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdateOrBuilder getStopTimeUpdateOrBuilder(
            int index) {
      return stopTimeUpdate_.get(index);
    }
    private void ensureStopTimeUpdateIsMutable() {
      if (!stopTimeUpdate_.isModifiable()) {
        stopTimeUpdate_ =
                com.google.protobuf.GeneratedMessageLite.mutableCopy(stopTimeUpdate_);
      }
    }

    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void setStopTimeUpdate(
            int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.set(index, value);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void setStopTimeUpdate(
            int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void addStopTimeUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.add(value);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void addStopTimeUpdate(
            int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.add(index, value);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void addStopTimeUpdate(
            com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void addStopTimeUpdate(
            int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void addAllStopTimeUpdate(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> values) {
      ensureStopTimeUpdateIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
              values, stopTimeUpdate_);
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void clearStopTimeUpdate() {
      stopTimeUpdate_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     * </pre>
     *
     * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
     */
    private void removeStopTimeUpdate(int index) {
      ensureStopTimeUpdateIsMutable();
      stopTimeUpdate_.remove(index);
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 4;
    private long timestamp_;
    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    private void setTimestamp(long value) {
      bitField0_ |= 0x00000004;
      timestamp_ = value;
    }
    /**
     * <pre>
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 4;</code>
     */
    private void clearTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000004);
      timestamp_ = 0L;
    }

    public static final int DELAY_FIELD_NUMBER = 5;
    private int delay_;
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    public boolean hasDelay() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    public int getDelay() {
      return delay_;
    }
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    private void setDelay(int value) {
      bitField0_ |= 0x00000008;
      delay_ = value;
    }
    /**
     * <pre>
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     * </pre>
     *
     * <code>optional int32 delay = 5;</code>
     */
    private void clearDelay() {
      bitField0_ = (bitField0_ & ~0x00000008);
      delay_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TripUpdate, com.google.transit.realtime.GtfsRealtime.TripUpdate.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getTrip());
      }
      for (int i = 0; i < stopTimeUpdate_.size(); i++) {
        output.writeMessage(2, stopTimeUpdate_.get(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(3, getVehicle());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(4, timestamp_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(5, delay_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, getTrip());
      }
      for (int i = 0; i < stopTimeUpdate_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(2, stopTimeUpdate_.get(i));
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(3, getVehicle());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt64Size(4, timestamp_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeInt32Size(5, delay_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripUpdate parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Realtime update of the progress of a vehicle along a trip.
     * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
     * - A trip that proceeds along the schedule.
     * - A trip that proceeds along a route but has no fixed schedule.
     * - A trip that have been added or removed with regard to schedule.
     * The updates can be for future, predicted arrival/departure events, or for
     * past events that already occurred.
     * Normally, updates should get more precise and more certain (see
     * uncertainty below) as the events gets closer to current time.
     * Even if that is not possible, the information for past events should be
     * precise and certain. In particular, if an update points to time in the past
     * but its update's uncertainty is not 0, the client should conclude that the
     * update is a (wrong) prediction and that the trip has not completed yet.
     * Note that the update can describe a trip that is already completed.
     * To this end, it is enough to provide an update for the last stop of the trip.
     * If the time of that is in the past, the client will conclude from that that
     * the whole trip is in the past (it is possible, although inconsequential, to
     * also provide updates for preceding stops).
     * This option is most relevant for a trip that has completed ahead of schedule,
     * but according to the schedule, the trip is still proceeding at the current
     * time. Removing the updates for this trip could make the client assume
     * that the trip is still proceeding.
     * Note that the feed provider is allowed, but not required, to purge past
     * updates - this is one case where this would be practically useful.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripUpdate}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.TripUpdate, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.TripUpdate)
            com.google.transit.realtime.GtfsRealtime.TripUpdateOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.TripUpdate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public boolean hasTrip() {
        return instance.hasTrip();
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        return instance.getTrip();
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.setTrip(value);
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setTrip(builderForValue);
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.mergeTrip(value);
        return this;
      }
      /**
       * <pre>
       * The Trip that this message applies to. There can be at most one
       * TripUpdate entity for each actual trip instance.
       * If there is none, that means there is no prediction information available.
       * It does *not* mean that the trip is progressing according to schedule.
       * </pre>
       *
       * <code>required .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder clearTrip() {  copyOnWrite();
        instance.clearTrip();
        return this;
      }

      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public boolean hasVehicle() {
        return instance.hasVehicle();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
        return instance.getVehicle();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        copyOnWrite();
        instance.setVehicle(value);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder setVehicle(
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setVehicle(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        copyOnWrite();
        instance.mergeVehicle(value);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 3;</code>
       */
      public Builder clearVehicle() {  copyOnWrite();
        instance.clearVehicle();
        return this;
      }

      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> getStopTimeUpdateList() {
        return java.util.Collections.unmodifiableList(
                instance.getStopTimeUpdateList());
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public int getStopTimeUpdateCount() {
        return instance.getStopTimeUpdateCount();
      }/**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate getStopTimeUpdate(int index) {
        return instance.getStopTimeUpdate(index);
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder setStopTimeUpdate(
              int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        copyOnWrite();
        instance.setStopTimeUpdate(index, value);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder setStopTimeUpdate(
              int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.setStopTimeUpdate(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        copyOnWrite();
        instance.addStopTimeUpdate(value);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
              int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate value) {
        copyOnWrite();
        instance.addStopTimeUpdate(index, value);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
              com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addStopTimeUpdate(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addStopTimeUpdate(
              int index, com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.Builder builderForValue) {
        copyOnWrite();
        instance.addStopTimeUpdate(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder addAllStopTimeUpdate(
              java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate> values) {
        copyOnWrite();
        instance.addAllStopTimeUpdate(values);
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder clearStopTimeUpdate() {
        copyOnWrite();
        instance.clearStopTimeUpdate();
        return this;
      }
      /**
       * <pre>
       * Updates to StopTimes for the trip (both future, i.e., predictions, and in
       * some cases, past ones, i.e., those that already happened).
       * The updates must be sorted by stop_sequence, and apply for all the
       * following stops of the trip up to the next specified one.
       * Example 1:
       * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
       * delay of 0 for stop_sequence of the current stop means that the trip is
       * exactly on time.
       * Example 2:
       * For the same trip instance, 3 StopTimeUpdates are provided:
       * - delay of 5 min for stop_sequence 3
       * - delay of 1 min for stop_sequence 8
       * - delay of unspecified duration for stop_sequence 10
       * This will be interpreted as:
       * - stop_sequences 3,4,5,6,7 have delay of 5 min.
       * - stop_sequences 8,9 have delay of 1 min.
       * - stop_sequences 10,... have unknown delay.
       * </pre>
       *
       * <code>repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;</code>
       */
      public Builder removeStopTimeUpdate(int index) {
        copyOnWrite();
        instance.removeStopTimeUpdate(index);
        return this;
      }

      /**
       * <pre>
       * Moment at which the vehicle's real-time progress was measured. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       */
      public boolean hasTimestamp() {
        return instance.hasTimestamp();
      }
      /**
       * <pre>
       * Moment at which the vehicle's real-time progress was measured. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       */
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * Moment at which the vehicle's real-time progress was measured. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Moment at which the vehicle's real-time progress was measured. In POSIX
       * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 4;</code>
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       */
      public boolean hasDelay() {
        return instance.hasDelay();
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       */
      public int getDelay() {
        return instance.getDelay();
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       */
      public Builder setDelay(int value) {
        copyOnWrite();
        instance.setDelay(value);
        return this;
      }
      /**
       * <pre>
       * The current schedule deviation for the trip.  Delay should only be
       * specified when the prediction is given relative to some existing schedule
       * in GTFS.
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       * Delay information in StopTimeUpdates take precedent of trip-level delay
       * information, such that trip-level delay is only propagated until the next
       * stop along the trip with a StopTimeUpdate delay value specified.
       * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
       * value indicating when the delay value was last updated, in order to
       * evaluate the freshness of the data.
       * NOTE: This field is still experimental, and subject to change. It may be
       * formally adopted in the future.
       * </pre>
       *
       * <code>optional int32 delay = 5;</code>
       */
      public Builder clearDelay() {
        copyOnWrite();
        instance.clearDelay();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TripUpdate)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.TripUpdate();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasTrip()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!getTrip().isInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (hasVehicle()) {
            if (!getVehicle().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          for (int i = 0; i < getStopTimeUpdateCount(); i++) {
            if (!getStopTimeUpdate(i).isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          stopTimeUpdate_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.TripUpdate other = (com.google.transit.realtime.GtfsRealtime.TripUpdate) arg1;
          trip_ = visitor.visitMessage(trip_, other.trip_);
          vehicle_ = visitor.visitMessage(vehicle_, other.vehicle_);
          stopTimeUpdate_= visitor.visitList(stopTimeUpdate_, other.stopTimeUpdate_);
          timestamp_ = visitor.visitLong(
                  hasTimestamp(), timestamp_,
                  other.hasTimestamp(), other.timestamp_);
          delay_ = visitor.visitInt(
                  hasDelay(), delay_,
                  other.hasDelay(), other.delay_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000001) == 0x00000001)) {
                    subBuilder = trip_.toBuilder();
                  }
                  trip_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripDescriptor.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(trip_);
                    trip_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000001;
                  break;
                }
                case 18: {
                  if (!stopTimeUpdate_.isModifiable()) {
                    stopTimeUpdate_ =
                            com.google.protobuf.GeneratedMessageLite.mutableCopy(stopTimeUpdate_);
                  }
                  stopTimeUpdate_.add(
                          input.readMessage(com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.parser(), extensionRegistry));
                  break;
                }
                case 26: {
                  com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000002) == 0x00000002)) {
                    subBuilder = vehicle_.toBuilder();
                  }
                  vehicle_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(vehicle_);
                    vehicle_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000002;
                  break;
                }
                case 32: {
                  bitField0_ |= 0x00000004;
                  timestamp_ = input.readUInt64();
                  break;
                }
                case 40: {
                  bitField0_ |= 0x00000008;
                  delay_ = input.readInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TripUpdate.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
    private static final com.google.transit.realtime.GtfsRealtime.TripUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new TripUpdate();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.TripUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TripUpdate> PARSER;

    public static com.google.protobuf.Parser<TripUpdate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VehiclePositionOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.VehiclePosition)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  VehiclePosition, VehiclePosition.Builder> {

    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    boolean hasTrip();
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();

    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    boolean hasVehicle();
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle();

    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    boolean hasPosition();
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    com.google.transit.realtime.GtfsRealtime.Position getPosition();

    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    boolean hasCurrentStopSequence();
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    int getCurrentStopSequence();

    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    boolean hasStopId();
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    java.lang.String getStopId();
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    com.google.protobuf.ByteString
    getStopIdBytes();

    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    boolean hasCurrentStatus();
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus();

    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    boolean hasTimestamp();
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    long getTimestamp();

    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    boolean hasCongestionLevel();
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel();

    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    boolean hasOccupancyStatus();
    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus();
  }
  /**
   * <pre>
   * Realtime positioning information for a given vehicle.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.VehiclePosition}
   */
  public  static final class VehiclePosition extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  VehiclePosition, VehiclePosition.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.VehiclePosition)
          VehiclePositionOrBuilder {
    private VehiclePosition() {
      stopId_ = "";
      currentStatus_ = 2;
    }
    /**
     * Protobuf enum {@code transit_realtime.VehiclePosition.VehicleStopStatus}
     */
    public enum VehicleStopStatus
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The vehicle is just about to arrive at the stop (on a stop
       * display, the vehicle symbol typically flashes).
       * </pre>
       *
       * <code>INCOMING_AT = 0;</code>
       */
      INCOMING_AT(0),
      /**
       * <pre>
       * The vehicle is standing at the stop.
       * </pre>
       *
       * <code>STOPPED_AT = 1;</code>
       */
      STOPPED_AT(1),
      /**
       * <pre>
       * The vehicle has departed and is in transit to the next stop.
       * </pre>
       *
       * <code>IN_TRANSIT_TO = 2;</code>
       */
      IN_TRANSIT_TO(2),
      ;

      /**
       * <pre>
       * The vehicle is just about to arrive at the stop (on a stop
       * display, the vehicle symbol typically flashes).
       * </pre>
       *
       * <code>INCOMING_AT = 0;</code>
       */
      public static final int INCOMING_AT_VALUE = 0;
      /**
       * <pre>
       * The vehicle is standing at the stop.
       * </pre>
       *
       * <code>STOPPED_AT = 1;</code>
       */
      public static final int STOPPED_AT_VALUE = 1;
      /**
       * <pre>
       * The vehicle has departed and is in transit to the next stop.
       * </pre>
       *
       * <code>IN_TRANSIT_TO = 2;</code>
       */
      public static final int IN_TRANSIT_TO_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static VehicleStopStatus valueOf(int value) {
        return forNumber(value);
      }

      public static VehicleStopStatus forNumber(int value) {
        switch (value) {
          case 0: return INCOMING_AT;
          case 1: return STOPPED_AT;
          case 2: return IN_TRANSIT_TO;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<VehicleStopStatus>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              VehicleStopStatus> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<VehicleStopStatus>() {
                public VehicleStopStatus findValueByNumber(int number) {
                  return VehicleStopStatus.forNumber(number);
                }
              };

      private final int value;

      private VehicleStopStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.VehicleStopStatus)
    }

    /**
     * <pre>
     * Congestion level that is affecting this vehicle.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.VehiclePosition.CongestionLevel}
     */
    public enum CongestionLevel
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN_CONGESTION_LEVEL = 0;</code>
       */
      UNKNOWN_CONGESTION_LEVEL(0),
      /**
       * <code>RUNNING_SMOOTHLY = 1;</code>
       */
      RUNNING_SMOOTHLY(1),
      /**
       * <code>STOP_AND_GO = 2;</code>
       */
      STOP_AND_GO(2),
      /**
       * <code>CONGESTION = 3;</code>
       */
      CONGESTION(3),
      /**
       * <pre>
       * People leaving their cars.
       * </pre>
       *
       * <code>SEVERE_CONGESTION = 4;</code>
       */
      SEVERE_CONGESTION(4),
      ;

      /**
       * <code>UNKNOWN_CONGESTION_LEVEL = 0;</code>
       */
      public static final int UNKNOWN_CONGESTION_LEVEL_VALUE = 0;
      /**
       * <code>RUNNING_SMOOTHLY = 1;</code>
       */
      public static final int RUNNING_SMOOTHLY_VALUE = 1;
      /**
       * <code>STOP_AND_GO = 2;</code>
       */
      public static final int STOP_AND_GO_VALUE = 2;
      /**
       * <code>CONGESTION = 3;</code>
       */
      public static final int CONGESTION_VALUE = 3;
      /**
       * <pre>
       * People leaving their cars.
       * </pre>
       *
       * <code>SEVERE_CONGESTION = 4;</code>
       */
      public static final int SEVERE_CONGESTION_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static CongestionLevel valueOf(int value) {
        return forNumber(value);
      }

      public static CongestionLevel forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_CONGESTION_LEVEL;
          case 1: return RUNNING_SMOOTHLY;
          case 2: return STOP_AND_GO;
          case 3: return CONGESTION;
          case 4: return SEVERE_CONGESTION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CongestionLevel>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              CongestionLevel> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<CongestionLevel>() {
                public CongestionLevel findValueByNumber(int number) {
                  return CongestionLevel.forNumber(number);
                }
              };

      private final int value;

      private CongestionLevel(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.CongestionLevel)
    }

    /**
     * <pre>
     * The degree of passenger occupancy of the vehicle. This field is still
     * experimental, and subject to change. It may be formally adopted in the
     * future.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.VehiclePosition.OccupancyStatus}
     */
    public enum OccupancyStatus
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * The vehicle is considered empty by most measures, and has few or no
       * passengers onboard, but is still accepting passengers.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      EMPTY(0),
      /**
       * <pre>
       * The vehicle has a relatively large percentage of seats available.
       * What percentage of free seats out of the total seats available is to be
       * considered large enough to fall into this category is determined at the
       * discretion of the producer.
       * </pre>
       *
       * <code>MANY_SEATS_AVAILABLE = 1;</code>
       */
      MANY_SEATS_AVAILABLE(1),
      /**
       * <pre>
       * The vehicle has a relatively small percentage of seats available.
       * What percentage of free seats out of the total seats available is to be
       * considered small enough to fall into this category is determined at the
       * discretion of the feed producer.
       * </pre>
       *
       * <code>FEW_SEATS_AVAILABLE = 2;</code>
       */
      FEW_SEATS_AVAILABLE(2),
      /**
       * <pre>
       * The vehicle can currently accommodate only standing passengers.
       * </pre>
       *
       * <code>STANDING_ROOM_ONLY = 3;</code>
       */
      STANDING_ROOM_ONLY(3),
      /**
       * <pre>
       * The vehicle can currently accommodate only standing passengers
       * and has limited space for them.
       * </pre>
       *
       * <code>CRUSHED_STANDING_ROOM_ONLY = 4;</code>
       */
      CRUSHED_STANDING_ROOM_ONLY(4),
      /**
       * <pre>
       * The vehicle is considered full by most measures, but may still be
       * allowing passengers to board.
       * </pre>
       *
       * <code>FULL = 5;</code>
       */
      FULL(5),
      /**
       * <pre>
       * The vehicle is not accepting additional passengers.
       * </pre>
       *
       * <code>NOT_ACCEPTING_PASSENGERS = 6;</code>
       */
      NOT_ACCEPTING_PASSENGERS(6),
      ;

      /**
       * <pre>
       * The vehicle is considered empty by most measures, and has few or no
       * passengers onboard, but is still accepting passengers.
       * </pre>
       *
       * <code>EMPTY = 0;</code>
       */
      public static final int EMPTY_VALUE = 0;
      /**
       * <pre>
       * The vehicle has a relatively large percentage of seats available.
       * What percentage of free seats out of the total seats available is to be
       * considered large enough to fall into this category is determined at the
       * discretion of the producer.
       * </pre>
       *
       * <code>MANY_SEATS_AVAILABLE = 1;</code>
       */
      public static final int MANY_SEATS_AVAILABLE_VALUE = 1;
      /**
       * <pre>
       * The vehicle has a relatively small percentage of seats available.
       * What percentage of free seats out of the total seats available is to be
       * considered small enough to fall into this category is determined at the
       * discretion of the feed producer.
       * </pre>
       *
       * <code>FEW_SEATS_AVAILABLE = 2;</code>
       */
      public static final int FEW_SEATS_AVAILABLE_VALUE = 2;
      /**
       * <pre>
       * The vehicle can currently accommodate only standing passengers.
       * </pre>
       *
       * <code>STANDING_ROOM_ONLY = 3;</code>
       */
      public static final int STANDING_ROOM_ONLY_VALUE = 3;
      /**
       * <pre>
       * The vehicle can currently accommodate only standing passengers
       * and has limited space for them.
       * </pre>
       *
       * <code>CRUSHED_STANDING_ROOM_ONLY = 4;</code>
       */
      public static final int CRUSHED_STANDING_ROOM_ONLY_VALUE = 4;
      /**
       * <pre>
       * The vehicle is considered full by most measures, but may still be
       * allowing passengers to board.
       * </pre>
       *
       * <code>FULL = 5;</code>
       */
      public static final int FULL_VALUE = 5;
      /**
       * <pre>
       * The vehicle is not accepting additional passengers.
       * </pre>
       *
       * <code>NOT_ACCEPTING_PASSENGERS = 6;</code>
       */
      public static final int NOT_ACCEPTING_PASSENGERS_VALUE = 6;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static OccupancyStatus valueOf(int value) {
        return forNumber(value);
      }

      public static OccupancyStatus forNumber(int value) {
        switch (value) {
          case 0: return EMPTY;
          case 1: return MANY_SEATS_AVAILABLE;
          case 2: return FEW_SEATS_AVAILABLE;
          case 3: return STANDING_ROOM_ONLY;
          case 4: return CRUSHED_STANDING_ROOM_ONLY;
          case 5: return FULL;
          case 6: return NOT_ACCEPTING_PASSENGERS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<OccupancyStatus>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              OccupancyStatus> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<OccupancyStatus>() {
                public OccupancyStatus findValueByNumber(int number) {
                  return OccupancyStatus.forNumber(number);
                }
              };

      private final int value;

      private OccupancyStatus(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.VehiclePosition.OccupancyStatus)
    }

    private int bitField0_;
    public static final int TRIP_FIELD_NUMBER = 1;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (value == null) {
        throw new NullPointerException();
      }
      trip_ = value;
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void setTrip(
            com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
      trip_ = builderForValue.build();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (trip_ != null &&
              trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
        trip_ =
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.newBuilder(trip_).mergeFrom(value).buildPartial();
      } else {
        trip_ = value;
      }
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     * </pre>
     *
     * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
     */
    private void clearTrip() {  trip_ = null;
      bitField0_ = (bitField0_ & ~0x00000001);
    }

    public static final int VEHICLE_FIELD_NUMBER = 8;
    private com.google.transit.realtime.GtfsRealtime.VehicleDescriptor vehicle_;
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    public boolean hasVehicle() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
      return vehicle_ == null ? com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance() : vehicle_;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    private void setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
      if (value == null) {
        throw new NullPointerException();
      }
      vehicle_ = value;
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    private void setVehicle(
            com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
      vehicle_ = builderForValue.build();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    private void mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
      if (vehicle_ != null &&
              vehicle_ != com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.getDefaultInstance()) {
        vehicle_ =
                com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.newBuilder(vehicle_).mergeFrom(value).buildPartial();
      } else {
        vehicle_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Additional information on the vehicle that is serving this trip.
     * </pre>
     *
     * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
     */
    private void clearVehicle() {  vehicle_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int POSITION_FIELD_NUMBER = 2;
    private com.google.transit.realtime.GtfsRealtime.Position position_;
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    public boolean hasPosition() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.Position getPosition() {
      return position_ == null ? com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance() : position_;
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    private void setPosition(com.google.transit.realtime.GtfsRealtime.Position value) {
      if (value == null) {
        throw new NullPointerException();
      }
      position_ = value;
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    private void setPosition(
            com.google.transit.realtime.GtfsRealtime.Position.Builder builderForValue) {
      position_ = builderForValue.build();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    private void mergePosition(com.google.transit.realtime.GtfsRealtime.Position value) {
      if (position_ != null &&
              position_ != com.google.transit.realtime.GtfsRealtime.Position.getDefaultInstance()) {
        position_ =
                com.google.transit.realtime.GtfsRealtime.Position.newBuilder(position_).mergeFrom(value).buildPartial();
      } else {
        position_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * Current position of this vehicle.
     * </pre>
     *
     * <code>optional .transit_realtime.Position position = 2;</code>
     */
    private void clearPosition() {  position_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int CURRENT_STOP_SEQUENCE_FIELD_NUMBER = 3;
    private int currentStopSequence_;
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    public boolean hasCurrentStopSequence() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    public int getCurrentStopSequence() {
      return currentStopSequence_;
    }
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    private void setCurrentStopSequence(int value) {
      bitField0_ |= 0x00000008;
      currentStopSequence_ = value;
    }
    /**
     * <pre>
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     * </pre>
     *
     * <code>optional uint32 current_stop_sequence = 3;</code>
     */
    private void clearCurrentStopSequence() {
      bitField0_ = (bitField0_ & ~0x00000008);
      currentStopSequence_ = 0;
    }

    public static final int STOP_ID_FIELD_NUMBER = 7;
    private java.lang.String stopId_;
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    public java.lang.String getStopId() {
      return stopId_;
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    public com.google.protobuf.ByteString
    getStopIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(stopId_);
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    private void setStopId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      stopId_ = value;
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    private void clearStopId() {
      bitField0_ = (bitField0_ & ~0x00000010);
      stopId_ = getDefaultInstance().getStopId();
    }
    /**
     * <pre>
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     * </pre>
     *
     * <code>optional string stop_id = 7;</code>
     */
    private void setStopIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      stopId_ = value.toStringUtf8();
    }

    public static final int CURRENT_STATUS_FIELD_NUMBER = 4;
    private int currentStatus_;
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    public boolean hasCurrentStatus() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.forNumber(currentStatus_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.IN_TRANSIT_TO : result;
    }
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    private void setCurrentStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000020;
      currentStatus_ = value.getNumber();
    }
    /**
     * <pre>
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     * </pre>
     *
     * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
     */
    private void clearCurrentStatus() {
      bitField0_ = (bitField0_ & ~0x00000020);
      currentStatus_ = 2;
    }

    public static final int TIMESTAMP_FIELD_NUMBER = 5;
    private long timestamp_;
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    public long getTimestamp() {
      return timestamp_;
    }
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    private void setTimestamp(long value) {
      bitField0_ |= 0x00000040;
      timestamp_ = value;
    }
    /**
     * <pre>
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     * </pre>
     *
     * <code>optional uint64 timestamp = 5;</code>
     */
    private void clearTimestamp() {
      bitField0_ = (bitField0_ & ~0x00000040);
      timestamp_ = 0L;
    }

    public static final int CONGESTION_LEVEL_FIELD_NUMBER = 6;
    private int congestionLevel_;
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    public boolean hasCongestionLevel() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.forNumber(congestionLevel_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.UNKNOWN_CONGESTION_LEVEL : result;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    private void setCongestionLevel(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000080;
      congestionLevel_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
     */
    private void clearCongestionLevel() {
      bitField0_ = (bitField0_ & ~0x00000080);
      congestionLevel_ = 0;
    }

    public static final int OCCUPANCY_STATUS_FIELD_NUMBER = 9;
    private int occupancyStatus_;
    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    public boolean hasOccupancyStatus() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
      com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus result = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(occupancyStatus_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.EMPTY : result;
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    private void setOccupancyStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000100;
      occupancyStatus_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
     */
    private void clearOccupancyStatus() {
      bitField0_ = (bitField0_ & ~0x00000100);
      occupancyStatus_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.VehiclePosition, com.google.transit.realtime.GtfsRealtime.VehiclePosition.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getTrip());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(2, getPosition());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(3, currentStopSequence_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeEnum(4, currentStatus_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeUInt64(5, timestamp_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeEnum(6, congestionLevel_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeString(7, getStopId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(8, getVehicle());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeEnum(9, occupancyStatus_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, getTrip());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(2, getPosition());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt32Size(3, currentStopSequence_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(4, currentStatus_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt64Size(5, timestamp_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(6, congestionLevel_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(7, getStopId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(8, getVehicle());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(9, occupancyStatus_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.VehiclePosition prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Realtime positioning information for a given vehicle.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.VehiclePosition}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.VehiclePosition, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.VehiclePosition)
            com.google.transit.realtime.GtfsRealtime.VehiclePositionOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.VehiclePosition.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public boolean hasTrip() {
        return instance.hasTrip();
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        return instance.getTrip();
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.setTrip(value);
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder setTrip(
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setTrip(builderForValue);
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.mergeTrip(value);
        return this;
      }
      /**
       * <pre>
       * The Trip that this vehicle is serving.
       * Can be empty or partial if the vehicle can not be identified with a given
       * trip instance.
       * </pre>
       *
       * <code>optional .transit_realtime.TripDescriptor trip = 1;</code>
       */
      public Builder clearTrip() {  copyOnWrite();
        instance.clearTrip();
        return this;
      }

      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public boolean hasVehicle() {
        return instance.hasVehicle();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getVehicle() {
        return instance.getVehicle();
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder setVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        copyOnWrite();
        instance.setVehicle(value);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder setVehicle(
              com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setVehicle(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder mergeVehicle(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor value) {
        copyOnWrite();
        instance.mergeVehicle(value);
        return this;
      }
      /**
       * <pre>
       * Additional information on the vehicle that is serving this trip.
       * </pre>
       *
       * <code>optional .transit_realtime.VehicleDescriptor vehicle = 8;</code>
       */
      public Builder clearVehicle() {  copyOnWrite();
        instance.clearVehicle();
        return this;
      }

      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public boolean hasPosition() {
        return instance.hasPosition();
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Position getPosition() {
        return instance.getPosition();
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder setPosition(com.google.transit.realtime.GtfsRealtime.Position value) {
        copyOnWrite();
        instance.setPosition(value);
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder setPosition(
              com.google.transit.realtime.GtfsRealtime.Position.Builder builderForValue) {
        copyOnWrite();
        instance.setPosition(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder mergePosition(com.google.transit.realtime.GtfsRealtime.Position value) {
        copyOnWrite();
        instance.mergePosition(value);
        return this;
      }
      /**
       * <pre>
       * Current position of this vehicle.
       * </pre>
       *
       * <code>optional .transit_realtime.Position position = 2;</code>
       */
      public Builder clearPosition() {  copyOnWrite();
        instance.clearPosition();
        return this;
      }

      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       */
      public boolean hasCurrentStopSequence() {
        return instance.hasCurrentStopSequence();
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       */
      public int getCurrentStopSequence() {
        return instance.getCurrentStopSequence();
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       */
      public Builder setCurrentStopSequence(int value) {
        copyOnWrite();
        instance.setCurrentStopSequence(value);
        return this;
      }
      /**
       * <pre>
       * The stop sequence index of the current stop. The meaning of
       * current_stop_sequence (i.e., the stop that it refers to) is determined by
       * current_status.
       * If current_status is missing IN_TRANSIT_TO is assumed.
       * </pre>
       *
       * <code>optional uint32 current_stop_sequence = 3;</code>
       */
      public Builder clearCurrentStopSequence() {
        copyOnWrite();
        instance.clearCurrentStopSequence();
        return this;
      }

      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public boolean hasStopId() {
        return instance.hasStopId();
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public java.lang.String getStopId() {
        return instance.getStopId();
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public com.google.protobuf.ByteString
      getStopIdBytes() {
        return instance.getStopIdBytes();
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public Builder setStopId(
              java.lang.String value) {
        copyOnWrite();
        instance.setStopId(value);
        return this;
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public Builder clearStopId() {
        copyOnWrite();
        instance.clearStopId();
        return this;
      }
      /**
       * <pre>
       * Identifies the current stop. The value must be the same as in stops.txt in
       * the corresponding GTFS feed.
       * </pre>
       *
       * <code>optional string stop_id = 7;</code>
       */
      public Builder setStopIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStopIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       */
      public boolean hasCurrentStatus() {
        return instance.hasCurrentStatus();
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus getCurrentStatus() {
        return instance.getCurrentStatus();
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       */
      public Builder setCurrentStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus value) {
        copyOnWrite();
        instance.setCurrentStatus(value);
        return this;
      }
      /**
       * <pre>
       * The exact status of the vehicle with respect to the current stop.
       * Ignored if current_stop_sequence is missing.
       * </pre>
       *
       * <code>optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];</code>
       */
      public Builder clearCurrentStatus() {
        copyOnWrite();
        instance.clearCurrentStatus();
        return this;
      }

      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       */
      public boolean hasTimestamp() {
        return instance.hasTimestamp();
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       */
      public long getTimestamp() {
        return instance.getTimestamp();
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       */
      public Builder setTimestamp(long value) {
        copyOnWrite();
        instance.setTimestamp(value);
        return this;
      }
      /**
       * <pre>
       * Moment at which the vehicle's position was measured. In POSIX time
       * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
       * </pre>
       *
       * <code>optional uint64 timestamp = 5;</code>
       */
      public Builder clearTimestamp() {
        copyOnWrite();
        instance.clearTimestamp();
        return this;
      }

      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       */
      public boolean hasCongestionLevel() {
        return instance.hasCongestionLevel();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel getCongestionLevel() {
        return instance.getCongestionLevel();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       */
      public Builder setCongestionLevel(com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel value) {
        copyOnWrite();
        instance.setCongestionLevel(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;</code>
       */
      public Builder clearCongestionLevel() {
        copyOnWrite();
        instance.clearCongestionLevel();
        return this;
      }

      /**
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       */
      public boolean hasOccupancyStatus() {
        return instance.hasOccupancyStatus();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus getOccupancyStatus() {
        return instance.getOccupancyStatus();
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       */
      public Builder setOccupancyStatus(com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value) {
        copyOnWrite();
        instance.setOccupancyStatus(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;</code>
       */
      public Builder clearOccupancyStatus() {
        copyOnWrite();
        instance.clearOccupancyStatus();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.VehiclePosition)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.VehiclePosition();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (hasTrip()) {
            if (!getTrip().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasVehicle()) {
            if (!getVehicle().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasPosition()) {
            if (!getPosition().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.VehiclePosition other = (com.google.transit.realtime.GtfsRealtime.VehiclePosition) arg1;
          trip_ = visitor.visitMessage(trip_, other.trip_);
          vehicle_ = visitor.visitMessage(vehicle_, other.vehicle_);
          position_ = visitor.visitMessage(position_, other.position_);
          currentStopSequence_ = visitor.visitInt(
                  hasCurrentStopSequence(), currentStopSequence_,
                  other.hasCurrentStopSequence(), other.currentStopSequence_);
          stopId_ = visitor.visitString(
                  hasStopId(), stopId_,
                  other.hasStopId(), other.stopId_);
          currentStatus_ = visitor.visitInt(hasCurrentStatus(), currentStatus_,
                  other.hasCurrentStatus(), other.currentStatus_);
          timestamp_ = visitor.visitLong(
                  hasTimestamp(), timestamp_,
                  other.hasTimestamp(), other.timestamp_);
          congestionLevel_ = visitor.visitInt(hasCongestionLevel(), congestionLevel_,
                  other.hasCongestionLevel(), other.congestionLevel_);
          occupancyStatus_ = visitor.visitInt(hasOccupancyStatus(), occupancyStatus_,
                  other.hasOccupancyStatus(), other.occupancyStatus_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000001) == 0x00000001)) {
                    subBuilder = trip_.toBuilder();
                  }
                  trip_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripDescriptor.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(trip_);
                    trip_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000001;
                  break;
                }
                case 18: {
                  com.google.transit.realtime.GtfsRealtime.Position.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000004) == 0x00000004)) {
                    subBuilder = position_.toBuilder();
                  }
                  position_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.Position.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(position_);
                    position_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000004;
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000008;
                  currentStopSequence_ = input.readUInt32();
                  break;
                }
                case 32: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus value = com.google.transit.realtime.GtfsRealtime.VehiclePosition.VehicleStopStatus.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(4, rawValue);
                  } else {
                    bitField0_ |= 0x00000020;
                    currentStatus_ = rawValue;
                  }
                  break;
                }
                case 40: {
                  bitField0_ |= 0x00000040;
                  timestamp_ = input.readUInt64();
                  break;
                }
                case 48: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel value = com.google.transit.realtime.GtfsRealtime.VehiclePosition.CongestionLevel.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(6, rawValue);
                  } else {
                    bitField0_ |= 0x00000080;
                    congestionLevel_ = rawValue;
                  }
                  break;
                }
                case 58: {
                  String s = input.readString();
                  bitField0_ |= 0x00000010;
                  stopId_ = s;
                  break;
                }
                case 66: {
                  com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000002) == 0x00000002)) {
                    subBuilder = vehicle_.toBuilder();
                  }
                  vehicle_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(vehicle_);
                    vehicle_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000002;
                  break;
                }
                case 72: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus value = com.google.transit.realtime.GtfsRealtime.VehiclePosition.OccupancyStatus.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(9, rawValue);
                  } else {
                    bitField0_ |= 0x00000100;
                    occupancyStatus_ = rawValue;
                  }
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.VehiclePosition.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
    private static final com.google.transit.realtime.GtfsRealtime.VehiclePosition DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new VehiclePosition();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.VehiclePosition getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VehiclePosition> PARSER;

    public static com.google.protobuf.Parser<VehiclePosition> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AlertOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.Alert)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  Alert, Alert.Builder> {

    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange>
    getActivePeriodList();
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index);
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    int getActivePeriodCount();

    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector>
    getInformedEntityList();
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index);
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    int getInformedEntityCount();

    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    boolean hasCause();
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause();

    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    boolean hasEffect();
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect();

    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    boolean hasUrl();
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl();

    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    boolean hasHeaderText();
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText();

    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    boolean hasDescriptionText();
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText();
  }
  /**
   * <pre>
   * An alert, indicating some sort of incident in the public transit network.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Alert}
   */
  public  static final class Alert extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  Alert, Alert.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.Alert)
          AlertOrBuilder {
    private Alert() {
      activePeriod_ = emptyProtobufList();
      informedEntity_ = emptyProtobufList();
      cause_ = 1;
      effect_ = 8;
    }
    /**
     * <pre>
     * Cause of this alert.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.Alert.Cause}
     */
    public enum Cause
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN_CAUSE = 1;</code>
       */
      UNKNOWN_CAUSE(1),
      /**
       * <pre>
       * Not machine-representable.
       * </pre>
       *
       * <code>OTHER_CAUSE = 2;</code>
       */
      OTHER_CAUSE(2),
      /**
       * <code>TECHNICAL_PROBLEM = 3;</code>
       */
      TECHNICAL_PROBLEM(3),
      /**
       * <pre>
       * Public transit agency employees stopped working.
       * </pre>
       *
       * <code>STRIKE = 4;</code>
       */
      STRIKE(4),
      /**
       * <pre>
       * People are blocking the streets.
       * </pre>
       *
       * <code>DEMONSTRATION = 5;</code>
       */
      DEMONSTRATION(5),
      /**
       * <code>ACCIDENT = 6;</code>
       */
      ACCIDENT(6),
      /**
       * <code>HOLIDAY = 7;</code>
       */
      HOLIDAY(7),
      /**
       * <code>WEATHER = 8;</code>
       */
      WEATHER(8),
      /**
       * <code>MAINTENANCE = 9;</code>
       */
      MAINTENANCE(9),
      /**
       * <code>CONSTRUCTION = 10;</code>
       */
      CONSTRUCTION(10),
      /**
       * <code>POLICE_ACTIVITY = 11;</code>
       */
      POLICE_ACTIVITY(11),
      /**
       * <code>MEDICAL_EMERGENCY = 12;</code>
       */
      MEDICAL_EMERGENCY(12),
      ;

      /**
       * <code>UNKNOWN_CAUSE = 1;</code>
       */
      public static final int UNKNOWN_CAUSE_VALUE = 1;
      /**
       * <pre>
       * Not machine-representable.
       * </pre>
       *
       * <code>OTHER_CAUSE = 2;</code>
       */
      public static final int OTHER_CAUSE_VALUE = 2;
      /**
       * <code>TECHNICAL_PROBLEM = 3;</code>
       */
      public static final int TECHNICAL_PROBLEM_VALUE = 3;
      /**
       * <pre>
       * Public transit agency employees stopped working.
       * </pre>
       *
       * <code>STRIKE = 4;</code>
       */
      public static final int STRIKE_VALUE = 4;
      /**
       * <pre>
       * People are blocking the streets.
       * </pre>
       *
       * <code>DEMONSTRATION = 5;</code>
       */
      public static final int DEMONSTRATION_VALUE = 5;
      /**
       * <code>ACCIDENT = 6;</code>
       */
      public static final int ACCIDENT_VALUE = 6;
      /**
       * <code>HOLIDAY = 7;</code>
       */
      public static final int HOLIDAY_VALUE = 7;
      /**
       * <code>WEATHER = 8;</code>
       */
      public static final int WEATHER_VALUE = 8;
      /**
       * <code>MAINTENANCE = 9;</code>
       */
      public static final int MAINTENANCE_VALUE = 9;
      /**
       * <code>CONSTRUCTION = 10;</code>
       */
      public static final int CONSTRUCTION_VALUE = 10;
      /**
       * <code>POLICE_ACTIVITY = 11;</code>
       */
      public static final int POLICE_ACTIVITY_VALUE = 11;
      /**
       * <code>MEDICAL_EMERGENCY = 12;</code>
       */
      public static final int MEDICAL_EMERGENCY_VALUE = 12;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Cause valueOf(int value) {
        return forNumber(value);
      }

      public static Cause forNumber(int value) {
        switch (value) {
          case 1: return UNKNOWN_CAUSE;
          case 2: return OTHER_CAUSE;
          case 3: return TECHNICAL_PROBLEM;
          case 4: return STRIKE;
          case 5: return DEMONSTRATION;
          case 6: return ACCIDENT;
          case 7: return HOLIDAY;
          case 8: return WEATHER;
          case 9: return MAINTENANCE;
          case 10: return CONSTRUCTION;
          case 11: return POLICE_ACTIVITY;
          case 12: return MEDICAL_EMERGENCY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Cause>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              Cause> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Cause>() {
                public Cause findValueByNumber(int number) {
                  return Cause.forNumber(number);
                }
              };

      private final int value;

      private Cause(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Alert.Cause)
    }

    /**
     * <pre>
     * What is the effect of this problem on the affected entity.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.Alert.Effect}
     */
    public enum Effect
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>NO_SERVICE = 1;</code>
       */
      NO_SERVICE(1),
      /**
       * <code>REDUCED_SERVICE = 2;</code>
       */
      REDUCED_SERVICE(2),
      /**
       * <pre>
       * We don't care about INsignificant delays: they are hard to detect, have
       * little impact on the user, and would clutter the results as they are too
       * frequent.
       * </pre>
       *
       * <code>SIGNIFICANT_DELAYS = 3;</code>
       */
      SIGNIFICANT_DELAYS(3),
      /**
       * <code>DETOUR = 4;</code>
       */
      DETOUR(4),
      /**
       * <code>ADDITIONAL_SERVICE = 5;</code>
       */
      ADDITIONAL_SERVICE(5),
      /**
       * <code>MODIFIED_SERVICE = 6;</code>
       */
      MODIFIED_SERVICE(6),
      /**
       * <code>OTHER_EFFECT = 7;</code>
       */
      OTHER_EFFECT(7),
      /**
       * <code>UNKNOWN_EFFECT = 8;</code>
       */
      UNKNOWN_EFFECT(8),
      /**
       * <code>STOP_MOVED = 9;</code>
       */
      STOP_MOVED(9),
      ;

      /**
       * <code>NO_SERVICE = 1;</code>
       */
      public static final int NO_SERVICE_VALUE = 1;
      /**
       * <code>REDUCED_SERVICE = 2;</code>
       */
      public static final int REDUCED_SERVICE_VALUE = 2;
      /**
       * <pre>
       * We don't care about INsignificant delays: they are hard to detect, have
       * little impact on the user, and would clutter the results as they are too
       * frequent.
       * </pre>
       *
       * <code>SIGNIFICANT_DELAYS = 3;</code>
       */
      public static final int SIGNIFICANT_DELAYS_VALUE = 3;
      /**
       * <code>DETOUR = 4;</code>
       */
      public static final int DETOUR_VALUE = 4;
      /**
       * <code>ADDITIONAL_SERVICE = 5;</code>
       */
      public static final int ADDITIONAL_SERVICE_VALUE = 5;
      /**
       * <code>MODIFIED_SERVICE = 6;</code>
       */
      public static final int MODIFIED_SERVICE_VALUE = 6;
      /**
       * <code>OTHER_EFFECT = 7;</code>
       */
      public static final int OTHER_EFFECT_VALUE = 7;
      /**
       * <code>UNKNOWN_EFFECT = 8;</code>
       */
      public static final int UNKNOWN_EFFECT_VALUE = 8;
      /**
       * <code>STOP_MOVED = 9;</code>
       */
      public static final int STOP_MOVED_VALUE = 9;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Effect valueOf(int value) {
        return forNumber(value);
      }

      public static Effect forNumber(int value) {
        switch (value) {
          case 1: return NO_SERVICE;
          case 2: return REDUCED_SERVICE;
          case 3: return SIGNIFICANT_DELAYS;
          case 4: return DETOUR;
          case 5: return ADDITIONAL_SERVICE;
          case 6: return MODIFIED_SERVICE;
          case 7: return OTHER_EFFECT;
          case 8: return UNKNOWN_EFFECT;
          case 9: return STOP_MOVED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Effect>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              Effect> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Effect>() {
                public Effect findValueByNumber(int number) {
                  return Effect.forNumber(number);
                }
              };

      private final int value;

      private Effect(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.Alert.Effect)
    }

    private int bitField0_;
    public static final int ACTIVE_PERIOD_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.transit.realtime.GtfsRealtime.TimeRange> activePeriod_;
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> getActivePeriodList() {
      return activePeriod_;
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder>
    getActivePeriodOrBuilderList() {
      return activePeriod_;
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    public int getActivePeriodCount() {
      return activePeriod_.size();
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index) {
      return activePeriod_.get(index);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder getActivePeriodOrBuilder(
            int index) {
      return activePeriod_.get(index);
    }
    private void ensureActivePeriodIsMutable() {
      if (!activePeriod_.isModifiable()) {
        activePeriod_ =
                com.google.protobuf.GeneratedMessageLite.mutableCopy(activePeriod_);
      }
    }

    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void setActivePeriod(
            int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureActivePeriodIsMutable();
      activePeriod_.set(index, value);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void setActivePeriod(
            int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
      ensureActivePeriodIsMutable();
      activePeriod_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void addActivePeriod(com.google.transit.realtime.GtfsRealtime.TimeRange value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureActivePeriodIsMutable();
      activePeriod_.add(value);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void addActivePeriod(
            int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureActivePeriodIsMutable();
      activePeriod_.add(index, value);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void addActivePeriod(
            com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
      ensureActivePeriodIsMutable();
      activePeriod_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void addActivePeriod(
            int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
      ensureActivePeriodIsMutable();
      activePeriod_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void addAllActivePeriod(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TimeRange> values) {
      ensureActivePeriodIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
              values, activePeriod_);
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void clearActivePeriod() {
      activePeriod_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Time when the alert should be shown to the user. If missing, the
     * alert will be shown as long as it appears in the feed.
     * If multiple ranges are given, the alert will be shown during all of them.
     * </pre>
     *
     * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
     */
    private void removeActivePeriod(int index) {
      ensureActivePeriodIsMutable();
      activePeriod_.remove(index);
    }

    public static final int INFORMED_ENTITY_FIELD_NUMBER = 5;
    private com.google.protobuf.Internal.ProtobufList<com.google.transit.realtime.GtfsRealtime.EntitySelector> informedEntity_;
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    public java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> getInformedEntityList() {
      return informedEntity_;
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder>
    getInformedEntityOrBuilderList() {
      return informedEntity_;
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    public int getInformedEntityCount() {
      return informedEntity_.size();
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index) {
      return informedEntity_.get(index);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder getInformedEntityOrBuilder(
            int index) {
      return informedEntity_.get(index);
    }
    private void ensureInformedEntityIsMutable() {
      if (!informedEntity_.isModifiable()) {
        informedEntity_ =
                com.google.protobuf.GeneratedMessageLite.mutableCopy(informedEntity_);
      }
    }

    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void setInformedEntity(
            int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInformedEntityIsMutable();
      informedEntity_.set(index, value);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void setInformedEntity(
            int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
      ensureInformedEntityIsMutable();
      informedEntity_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void addInformedEntity(com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInformedEntityIsMutable();
      informedEntity_.add(value);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void addInformedEntity(
            int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureInformedEntityIsMutable();
      informedEntity_.add(index, value);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void addInformedEntity(
            com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
      ensureInformedEntityIsMutable();
      informedEntity_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void addInformedEntity(
            int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
      ensureInformedEntityIsMutable();
      informedEntity_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void addAllInformedEntity(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.EntitySelector> values) {
      ensureInformedEntityIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
              values, informedEntity_);
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void clearInformedEntity() {
      informedEntity_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Entities whose users we should notify of this alert.
     * </pre>
     *
     * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
     */
    private void removeInformedEntity(int index) {
      ensureInformedEntityIsMutable();
      informedEntity_.remove(index);
    }

    public static final int CAUSE_FIELD_NUMBER = 6;
    private int cause_;
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    public boolean hasCause() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    public com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause() {
      com.google.transit.realtime.GtfsRealtime.Alert.Cause result = com.google.transit.realtime.GtfsRealtime.Alert.Cause.forNumber(cause_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Cause.UNKNOWN_CAUSE : result;
    }
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    private void setCause(com.google.transit.realtime.GtfsRealtime.Alert.Cause value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      cause_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
     */
    private void clearCause() {
      bitField0_ = (bitField0_ & ~0x00000001);
      cause_ = 1;
    }

    public static final int EFFECT_FIELD_NUMBER = 7;
    private int effect_;
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    public boolean hasEffect() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    public com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect() {
      com.google.transit.realtime.GtfsRealtime.Alert.Effect result = com.google.transit.realtime.GtfsRealtime.Alert.Effect.forNumber(effect_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.Alert.Effect.UNKNOWN_EFFECT : result;
    }
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    private void setEffect(com.google.transit.realtime.GtfsRealtime.Alert.Effect value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      effect_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
     */
    private void clearEffect() {
      bitField0_ = (bitField0_ & ~0x00000002);
      effect_ = 8;
    }

    public static final int URL_FIELD_NUMBER = 8;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString url_;
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    public boolean hasUrl() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl() {
      return url_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : url_;
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    private void setUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      url_ = value;
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    private void setUrl(
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
      url_ = builderForValue.build();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    private void mergeUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (url_ != null &&
              url_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
        url_ =
                com.google.transit.realtime.GtfsRealtime.TranslatedString.newBuilder(url_).mergeFrom(value).buildPartial();
      } else {
        url_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * The URL which provides additional information about the alert.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString url = 8;</code>
     */
    private void clearUrl() {  url_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int HEADER_TEXT_FIELD_NUMBER = 10;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString headerText_;
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    public boolean hasHeaderText() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText() {
      return headerText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : headerText_;
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    private void setHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      headerText_ = value;
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    private void setHeaderText(
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
      headerText_ = builderForValue.build();
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    private void mergeHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (headerText_ != null &&
              headerText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
        headerText_ =
                com.google.transit.realtime.GtfsRealtime.TranslatedString.newBuilder(headerText_).mergeFrom(value).buildPartial();
      } else {
        headerText_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * Alert header. Contains a short summary of the alert text as plain-text.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
     */
    private void clearHeaderText() {  headerText_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int DESCRIPTION_TEXT_FIELD_NUMBER = 11;
    private com.google.transit.realtime.GtfsRealtime.TranslatedString descriptionText_;
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    public boolean hasDescriptionText() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText() {
      return descriptionText_ == null ? com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance() : descriptionText_;
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    private void setDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      descriptionText_ = value;
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    private void setDescriptionText(
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
      descriptionText_ = builderForValue.build();
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    private void mergeDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
      if (descriptionText_ != null &&
              descriptionText_ != com.google.transit.realtime.GtfsRealtime.TranslatedString.getDefaultInstance()) {
        descriptionText_ =
                com.google.transit.realtime.GtfsRealtime.TranslatedString.newBuilder(descriptionText_).mergeFrom(value).buildPartial();
      } else {
        descriptionText_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <pre>
     * Full description for the alert as plain-text. The information in the
     * description should add to the information of the header.
     * </pre>
     *
     * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
     */
    private void clearDescriptionText() {  descriptionText_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.Alert, com.google.transit.realtime.GtfsRealtime.Alert.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      for (int i = 0; i < activePeriod_.size(); i++) {
        output.writeMessage(1, activePeriod_.get(i));
      }
      for (int i = 0; i < informedEntity_.size(); i++) {
        output.writeMessage(5, informedEntity_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(6, cause_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeEnum(7, effect_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(8, getUrl());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(10, getHeaderText());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(11, getDescriptionText());
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < activePeriod_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, activePeriod_.get(i));
      }
      for (int i = 0; i < informedEntity_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(5, informedEntity_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(6, cause_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(7, effect_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(8, getUrl());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(10, getHeaderText());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(11, getDescriptionText());
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Alert parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Alert prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * An alert, indicating some sort of incident in the public transit network.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Alert}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.Alert, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.Alert)
            com.google.transit.realtime.GtfsRealtime.AlertOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.Alert.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TimeRange> getActivePeriodList() {
        return java.util.Collections.unmodifiableList(
                instance.getActivePeriodList());
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public int getActivePeriodCount() {
        return instance.getActivePeriodCount();
      }/**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TimeRange getActivePeriod(int index) {
        return instance.getActivePeriod(index);
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder setActivePeriod(
              int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        copyOnWrite();
        instance.setActivePeriod(index, value);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder setActivePeriod(
              int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        copyOnWrite();
        instance.setActivePeriod(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        copyOnWrite();
        instance.addActivePeriod(value);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
              int index, com.google.transit.realtime.GtfsRealtime.TimeRange value) {
        copyOnWrite();
        instance.addActivePeriod(index, value);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
              com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        copyOnWrite();
        instance.addActivePeriod(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addActivePeriod(
              int index, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder builderForValue) {
        copyOnWrite();
        instance.addActivePeriod(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder addAllActivePeriod(
              java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TimeRange> values) {
        copyOnWrite();
        instance.addAllActivePeriod(values);
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder clearActivePeriod() {
        copyOnWrite();
        instance.clearActivePeriod();
        return this;
      }
      /**
       * <pre>
       * Time when the alert should be shown to the user. If missing, the
       * alert will be shown as long as it appears in the feed.
       * If multiple ranges are given, the alert will be shown during all of them.
       * </pre>
       *
       * <code>repeated .transit_realtime.TimeRange active_period = 1;</code>
       */
      public Builder removeActivePeriod(int index) {
        copyOnWrite();
        instance.removeActivePeriod(index);
        return this;
      }

      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.EntitySelector> getInformedEntityList() {
        return java.util.Collections.unmodifiableList(
                instance.getInformedEntityList());
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public int getInformedEntityCount() {
        return instance.getInformedEntityCount();
      }/**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.EntitySelector getInformedEntity(int index) {
        return instance.getInformedEntity(index);
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder setInformedEntity(
              int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        copyOnWrite();
        instance.setInformedEntity(index, value);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder setInformedEntity(
              int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        copyOnWrite();
        instance.setInformedEntity(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        copyOnWrite();
        instance.addInformedEntity(value);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
              int index, com.google.transit.realtime.GtfsRealtime.EntitySelector value) {
        copyOnWrite();
        instance.addInformedEntity(index, value);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
              com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        copyOnWrite();
        instance.addInformedEntity(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addInformedEntity(
              int index, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder builderForValue) {
        copyOnWrite();
        instance.addInformedEntity(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder addAllInformedEntity(
              java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.EntitySelector> values) {
        copyOnWrite();
        instance.addAllInformedEntity(values);
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder clearInformedEntity() {
        copyOnWrite();
        instance.clearInformedEntity();
        return this;
      }
      /**
       * <pre>
       * Entities whose users we should notify of this alert.
       * </pre>
       *
       * <code>repeated .transit_realtime.EntitySelector informed_entity = 5;</code>
       */
      public Builder removeInformedEntity(int index) {
        copyOnWrite();
        instance.removeInformedEntity(index);
        return this;
      }

      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       */
      public boolean hasCause() {
        return instance.hasCause();
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Alert.Cause getCause() {
        return instance.getCause();
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       */
      public Builder setCause(com.google.transit.realtime.GtfsRealtime.Alert.Cause value) {
        copyOnWrite();
        instance.setCause(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];</code>
       */
      public Builder clearCause() {
        copyOnWrite();
        instance.clearCause();
        return this;
      }

      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       */
      public boolean hasEffect() {
        return instance.hasEffect();
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       */
      public com.google.transit.realtime.GtfsRealtime.Alert.Effect getEffect() {
        return instance.getEffect();
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       */
      public Builder setEffect(com.google.transit.realtime.GtfsRealtime.Alert.Effect value) {
        copyOnWrite();
        instance.setEffect(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];</code>
       */
      public Builder clearEffect() {
        copyOnWrite();
        instance.clearEffect();
        return this;
      }

      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public boolean hasUrl() {
        return instance.hasUrl();
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getUrl() {
        return instance.getUrl();
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder setUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.setUrl(value);
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder setUrl(
              com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        copyOnWrite();
        instance.setUrl(builderForValue);
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder mergeUrl(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.mergeUrl(value);
        return this;
      }
      /**
       * <pre>
       * The URL which provides additional information about the alert.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString url = 8;</code>
       */
      public Builder clearUrl() {  copyOnWrite();
        instance.clearUrl();
        return this;
      }

      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public boolean hasHeaderText() {
        return instance.hasHeaderText();
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getHeaderText() {
        return instance.getHeaderText();
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder setHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.setHeaderText(value);
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder setHeaderText(
              com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        copyOnWrite();
        instance.setHeaderText(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder mergeHeaderText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.mergeHeaderText(value);
        return this;
      }
      /**
       * <pre>
       * Alert header. Contains a short summary of the alert text as plain-text.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString header_text = 10;</code>
       */
      public Builder clearHeaderText() {  copyOnWrite();
        instance.clearHeaderText();
        return this;
      }

      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public boolean hasDescriptionText() {
        return instance.hasDescriptionText();
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString getDescriptionText() {
        return instance.getDescriptionText();
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder setDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.setDescriptionText(value);
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder setDescriptionText(
              com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder builderForValue) {
        copyOnWrite();
        instance.setDescriptionText(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder mergeDescriptionText(com.google.transit.realtime.GtfsRealtime.TranslatedString value) {
        copyOnWrite();
        instance.mergeDescriptionText(value);
        return this;
      }
      /**
       * <pre>
       * Full description for the alert as plain-text. The information in the
       * description should add to the information of the header.
       * </pre>
       *
       * <code>optional .transit_realtime.TranslatedString description_text = 11;</code>
       */
      public Builder clearDescriptionText() {  copyOnWrite();
        instance.clearDescriptionText();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Alert)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.Alert();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          for (int i = 0; i < getActivePeriodCount(); i++) {
            if (!getActivePeriod(i).isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          for (int i = 0; i < getInformedEntityCount(); i++) {
            if (!getInformedEntity(i).isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasUrl()) {
            if (!getUrl().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasHeaderText()) {
            if (!getHeaderText().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasDescriptionText()) {
            if (!getDescriptionText().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          activePeriod_.makeImmutable();
          informedEntity_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.Alert other = (com.google.transit.realtime.GtfsRealtime.Alert) arg1;
          activePeriod_= visitor.visitList(activePeriod_, other.activePeriod_);
          informedEntity_= visitor.visitList(informedEntity_, other.informedEntity_);
          cause_ = visitor.visitInt(hasCause(), cause_,
                  other.hasCause(), other.cause_);
          effect_ = visitor.visitInt(hasEffect(), effect_,
                  other.hasEffect(), other.effect_);
          url_ = visitor.visitMessage(url_, other.url_);
          headerText_ = visitor.visitMessage(headerText_, other.headerText_);
          descriptionText_ = visitor.visitMessage(descriptionText_, other.descriptionText_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!activePeriod_.isModifiable()) {
                    activePeriod_ =
                            com.google.protobuf.GeneratedMessageLite.mutableCopy(activePeriod_);
                  }
                  activePeriod_.add(
                          input.readMessage(com.google.transit.realtime.GtfsRealtime.TimeRange.parser(), extensionRegistry));
                  break;
                }
                case 42: {
                  if (!informedEntity_.isModifiable()) {
                    informedEntity_ =
                            com.google.protobuf.GeneratedMessageLite.mutableCopy(informedEntity_);
                  }
                  informedEntity_.add(
                          input.readMessage(com.google.transit.realtime.GtfsRealtime.EntitySelector.parser(), extensionRegistry));
                  break;
                }
                case 48: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.Alert.Cause value = com.google.transit.realtime.GtfsRealtime.Alert.Cause.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(6, rawValue);
                  } else {
                    bitField0_ |= 0x00000001;
                    cause_ = rawValue;
                  }
                  break;
                }
                case 56: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.Alert.Effect value = com.google.transit.realtime.GtfsRealtime.Alert.Effect.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(7, rawValue);
                  } else {
                    bitField0_ |= 0x00000002;
                    effect_ = rawValue;
                  }
                  break;
                }
                case 66: {
                  com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000004) == 0x00000004)) {
                    subBuilder = url_.toBuilder();
                  }
                  url_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TranslatedString.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(url_);
                    url_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000004;
                  break;
                }
                case 82: {
                  com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000008) == 0x00000008)) {
                    subBuilder = headerText_.toBuilder();
                  }
                  headerText_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TranslatedString.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(headerText_);
                    headerText_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000008;
                  break;
                }
                case 90: {
                  com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000010) == 0x00000010)) {
                    subBuilder = descriptionText_.toBuilder();
                  }
                  descriptionText_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TranslatedString.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(descriptionText_);
                    descriptionText_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000010;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.Alert.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
    private static final com.google.transit.realtime.GtfsRealtime.Alert DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Alert();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.Alert getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Alert> PARSER;

    public static com.google.protobuf.Parser<Alert> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TimeRangeOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.TimeRange)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  TimeRange, TimeRange.Builder> {

    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    boolean hasStart();
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    long getStart();

    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    boolean hasEnd();
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    long getEnd();
  }
  /**
   * <pre>
   * A time interval. The interval is considered active at time 't' if 't' is
   * greater than or equal to the start time and less than the end time.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TimeRange}
   */
  public  static final class TimeRange extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  TimeRange, TimeRange.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.TimeRange)
          TimeRangeOrBuilder {
    private TimeRange() {
    }
    private int bitField0_;
    public static final int START_FIELD_NUMBER = 1;
    private long start_;
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    public boolean hasStart() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    public long getStart() {
      return start_;
    }
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    private void setStart(long value) {
      bitField0_ |= 0x00000001;
      start_ = value;
    }
    /**
     * <pre>
     * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval starts at minus infinity.
     * </pre>
     *
     * <code>optional uint64 start = 1;</code>
     */
    private void clearStart() {
      bitField0_ = (bitField0_ & ~0x00000001);
      start_ = 0L;
    }

    public static final int END_FIELD_NUMBER = 2;
    private long end_;
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    public boolean hasEnd() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    public long getEnd() {
      return end_;
    }
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    private void setEnd(long value) {
      bitField0_ |= 0x00000002;
      end_ = value;
    }
    /**
     * <pre>
     * End time, in POSIX time (i.e., number of seconds since January 1st 1970
     * 00:00:00 UTC).
     * If missing, the interval ends at plus infinity.
     * </pre>
     *
     * <code>optional uint64 end = 2;</code>
     */
    private void clearEnd() {
      bitField0_ = (bitField0_ & ~0x00000002);
      end_ = 0L;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TimeRange, com.google.transit.realtime.GtfsRealtime.TimeRange.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt64(1, start_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt64(2, end_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt64Size(1, start_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt64Size(2, end_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TimeRange parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TimeRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A time interval. The interval is considered active at time 't' if 't' is
     * greater than or equal to the start time and less than the end time.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TimeRange}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.TimeRange, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.TimeRange)
            com.google.transit.realtime.GtfsRealtime.TimeRangeOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.TimeRange.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       */
      public boolean hasStart() {
        return instance.hasStart();
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       */
      public long getStart() {
        return instance.getStart();
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       */
      public Builder setStart(long value) {
        copyOnWrite();
        instance.setStart(value);
        return this;
      }
      /**
       * <pre>
       * Start time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval starts at minus infinity.
       * </pre>
       *
       * <code>optional uint64 start = 1;</code>
       */
      public Builder clearStart() {
        copyOnWrite();
        instance.clearStart();
        return this;
      }

      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       */
      public boolean hasEnd() {
        return instance.hasEnd();
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       */
      public long getEnd() {
        return instance.getEnd();
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       */
      public Builder setEnd(long value) {
        copyOnWrite();
        instance.setEnd(value);
        return this;
      }
      /**
       * <pre>
       * End time, in POSIX time (i.e., number of seconds since January 1st 1970
       * 00:00:00 UTC).
       * If missing, the interval ends at plus infinity.
       * </pre>
       *
       * <code>optional uint64 end = 2;</code>
       */
      public Builder clearEnd() {
        copyOnWrite();
        instance.clearEnd();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TimeRange)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.TimeRange();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.TimeRange other = (com.google.transit.realtime.GtfsRealtime.TimeRange) arg1;
          start_ = visitor.visitLong(
                  hasStart(), start_,
                  other.hasStart(), other.start_);
          end_ = visitor.visitLong(
                  hasEnd(), end_,
                  other.hasEnd(), other.end_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  bitField0_ |= 0x00000001;
                  start_ = input.readUInt64();
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000002;
                  end_ = input.readUInt64();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TimeRange.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
    private static final com.google.transit.realtime.GtfsRealtime.TimeRange DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new TimeRange();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.TimeRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TimeRange> PARSER;

    public static com.google.protobuf.Parser<TimeRange> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PositionOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.Position)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  Position, Position.Builder> {

    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    boolean hasLatitude();
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    float getLatitude();

    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    boolean hasLongitude();
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    float getLongitude();

    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    boolean hasBearing();
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    float getBearing();

    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    boolean hasOdometer();
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    double getOdometer();

    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    boolean hasSpeed();
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    float getSpeed();
  }
  /**
   * <pre>
   * A position.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.Position}
   */
  public  static final class Position extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  Position, Position.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.Position)
          PositionOrBuilder {
    private Position() {
    }
    private int bitField0_;
    public static final int LATITUDE_FIELD_NUMBER = 1;
    private float latitude_;
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    public boolean hasLatitude() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    public float getLatitude() {
      return latitude_;
    }
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    private void setLatitude(float value) {
      bitField0_ |= 0x00000001;
      latitude_ = value;
    }
    /**
     * <pre>
     * Degrees North, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float latitude = 1;</code>
     */
    private void clearLatitude() {
      bitField0_ = (bitField0_ & ~0x00000001);
      latitude_ = 0F;
    }

    public static final int LONGITUDE_FIELD_NUMBER = 2;
    private float longitude_;
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    public boolean hasLongitude() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    public float getLongitude() {
      return longitude_;
    }
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    private void setLongitude(float value) {
      bitField0_ |= 0x00000002;
      longitude_ = value;
    }
    /**
     * <pre>
     * Degrees East, in the WGS-84 coordinate system.
     * </pre>
     *
     * <code>required float longitude = 2;</code>
     */
    private void clearLongitude() {
      bitField0_ = (bitField0_ & ~0x00000002);
      longitude_ = 0F;
    }

    public static final int BEARING_FIELD_NUMBER = 3;
    private float bearing_;
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    public boolean hasBearing() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    public float getBearing() {
      return bearing_;
    }
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    private void setBearing(float value) {
      bitField0_ |= 0x00000004;
      bearing_ = value;
    }
    /**
     * <pre>
     * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
     * This can be the compass bearing, or the direction towards the next stop
     * or intermediate location.
     * This should not be direction deduced from the sequence of previous
     * positions, which can be computed from previous data.
     * </pre>
     *
     * <code>optional float bearing = 3;</code>
     */
    private void clearBearing() {
      bitField0_ = (bitField0_ & ~0x00000004);
      bearing_ = 0F;
    }

    public static final int ODOMETER_FIELD_NUMBER = 4;
    private double odometer_;
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    public boolean hasOdometer() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    public double getOdometer() {
      return odometer_;
    }
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    private void setOdometer(double value) {
      bitField0_ |= 0x00000008;
      odometer_ = value;
    }
    /**
     * <pre>
     * Odometer value, in meters.
     * </pre>
     *
     * <code>optional double odometer = 4;</code>
     */
    private void clearOdometer() {
      bitField0_ = (bitField0_ & ~0x00000008);
      odometer_ = 0D;
    }

    public static final int SPEED_FIELD_NUMBER = 5;
    private float speed_;
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    public boolean hasSpeed() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    public float getSpeed() {
      return speed_;
    }
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    private void setSpeed(float value) {
      bitField0_ |= 0x00000010;
      speed_ = value;
    }
    /**
     * <pre>
     * Momentary speed measured by the vehicle, in meters per second.
     * </pre>
     *
     * <code>optional float speed = 5;</code>
     */
    private void clearSpeed() {
      bitField0_ = (bitField0_ & ~0x00000010);
      speed_ = 0F;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.Position, com.google.transit.realtime.GtfsRealtime.Position.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeFloat(1, latitude_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeFloat(2, longitude_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeFloat(3, bearing_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeDouble(4, odometer_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeFloat(5, speed_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeFloatSize(1, latitude_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeFloatSize(2, longitude_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeFloatSize(3, bearing_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeDoubleSize(4, odometer_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeFloatSize(5, speed_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.Position parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.Position prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A position.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.Position}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.Position, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.Position)
            com.google.transit.realtime.GtfsRealtime.PositionOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.Position.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       */
      public boolean hasLatitude() {
        return instance.hasLatitude();
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       */
      public float getLatitude() {
        return instance.getLatitude();
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       */
      public Builder setLatitude(float value) {
        copyOnWrite();
        instance.setLatitude(value);
        return this;
      }
      /**
       * <pre>
       * Degrees North, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float latitude = 1;</code>
       */
      public Builder clearLatitude() {
        copyOnWrite();
        instance.clearLatitude();
        return this;
      }

      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       */
      public boolean hasLongitude() {
        return instance.hasLongitude();
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       */
      public float getLongitude() {
        return instance.getLongitude();
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       */
      public Builder setLongitude(float value) {
        copyOnWrite();
        instance.setLongitude(value);
        return this;
      }
      /**
       * <pre>
       * Degrees East, in the WGS-84 coordinate system.
       * </pre>
       *
       * <code>required float longitude = 2;</code>
       */
      public Builder clearLongitude() {
        copyOnWrite();
        instance.clearLongitude();
        return this;
      }

      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       */
      public boolean hasBearing() {
        return instance.hasBearing();
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       */
      public float getBearing() {
        return instance.getBearing();
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       */
      public Builder setBearing(float value) {
        copyOnWrite();
        instance.setBearing(value);
        return this;
      }
      /**
       * <pre>
       * Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
       * This can be the compass bearing, or the direction towards the next stop
       * or intermediate location.
       * This should not be direction deduced from the sequence of previous
       * positions, which can be computed from previous data.
       * </pre>
       *
       * <code>optional float bearing = 3;</code>
       */
      public Builder clearBearing() {
        copyOnWrite();
        instance.clearBearing();
        return this;
      }

      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       */
      public boolean hasOdometer() {
        return instance.hasOdometer();
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       */
      public double getOdometer() {
        return instance.getOdometer();
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       */
      public Builder setOdometer(double value) {
        copyOnWrite();
        instance.setOdometer(value);
        return this;
      }
      /**
       * <pre>
       * Odometer value, in meters.
       * </pre>
       *
       * <code>optional double odometer = 4;</code>
       */
      public Builder clearOdometer() {
        copyOnWrite();
        instance.clearOdometer();
        return this;
      }

      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       */
      public boolean hasSpeed() {
        return instance.hasSpeed();
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       */
      public float getSpeed() {
        return instance.getSpeed();
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       */
      public Builder setSpeed(float value) {
        copyOnWrite();
        instance.setSpeed(value);
        return this;
      }
      /**
       * <pre>
       * Momentary speed measured by the vehicle, in meters per second.
       * </pre>
       *
       * <code>optional float speed = 5;</code>
       */
      public Builder clearSpeed() {
        copyOnWrite();
        instance.clearSpeed();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.Position)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.Position();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasLatitude()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasLongitude()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.Position other = (com.google.transit.realtime.GtfsRealtime.Position) arg1;
          latitude_ = visitor.visitFloat(
                  hasLatitude(), latitude_,
                  other.hasLatitude(), other.latitude_);
          longitude_ = visitor.visitFloat(
                  hasLongitude(), longitude_,
                  other.hasLongitude(), other.longitude_);
          bearing_ = visitor.visitFloat(
                  hasBearing(), bearing_,
                  other.hasBearing(), other.bearing_);
          odometer_ = visitor.visitDouble(
                  hasOdometer(), odometer_,
                  other.hasOdometer(), other.odometer_);
          speed_ = visitor.visitFloat(
                  hasSpeed(), speed_,
                  other.hasSpeed(), other.speed_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 13: {
                  bitField0_ |= 0x00000001;
                  latitude_ = input.readFloat();
                  break;
                }
                case 21: {
                  bitField0_ |= 0x00000002;
                  longitude_ = input.readFloat();
                  break;
                }
                case 29: {
                  bitField0_ |= 0x00000004;
                  bearing_ = input.readFloat();
                  break;
                }
                case 33: {
                  bitField0_ |= 0x00000008;
                  odometer_ = input.readDouble();
                  break;
                }
                case 45: {
                  bitField0_ |= 0x00000010;
                  speed_ = input.readFloat();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.Position.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.Position)
    private static final com.google.transit.realtime.GtfsRealtime.Position DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Position();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.Position getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Position> PARSER;

    public static com.google.protobuf.Parser<Position> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TripDescriptorOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.TripDescriptor)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  TripDescriptor, TripDescriptor.Builder> {

    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    boolean hasTripId();
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    java.lang.String getTripId();
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    com.google.protobuf.ByteString
    getTripIdBytes();

    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    boolean hasRouteId();
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    java.lang.String getRouteId();
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    com.google.protobuf.ByteString
    getRouteIdBytes();

    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    boolean hasDirectionId();
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    int getDirectionId();

    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    boolean hasStartTime();
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    java.lang.String getStartTime();
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    com.google.protobuf.ByteString
    getStartTimeBytes();

    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    boolean hasStartDate();
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    java.lang.String getStartDate();
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    com.google.protobuf.ByteString
    getStartDateBytes();

    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    boolean hasScheduleRelationship();
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship();
  }
  /**
   * <pre>
   * A descriptor that identifies an instance of a GTFS trip, or all instances of
   * a trip along a route.
   * - To specify a single trip instance, the trip_id (and if necessary,
   *   start_time) is set. If route_id is also set, then it should be same as one
   *   that the given trip corresponds to.
   * - To specify all the trips along a given route, only the route_id should be
   *   set. Note that if the trip_id is not known, then stop sequence ids in
   *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
   *   addition, absolute arrival/departure times must be provided.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TripDescriptor}
   */
  public  static final class TripDescriptor extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  TripDescriptor, TripDescriptor.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.TripDescriptor)
          TripDescriptorOrBuilder {
    private TripDescriptor() {
      tripId_ = "";
      routeId_ = "";
      startTime_ = "";
      startDate_ = "";
    }
    /**
     * <pre>
     * The relation between this trip and the static schedule. If a trip is done
     * in accordance with temporary schedule, not reflected in GTFS, then it
     * shouldn't be marked as SCHEDULED, but likely as ADDED.
     * </pre>
     *
     * Protobuf enum {@code transit_realtime.TripDescriptor.ScheduleRelationship}
     */
    public enum ScheduleRelationship
            implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Trip that is running in accordance with its GTFS schedule, or is close
       * enough to the scheduled trip to be associated with it.
       * </pre>
       *
       * <code>SCHEDULED = 0;</code>
       */
      SCHEDULED(0),
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for
       * example, to replace a broken vehicle or to respond to sudden passenger
       * load.
       * </pre>
       *
       * <code>ADDED = 1;</code>
       */
      ADDED(1),
      /**
       * <pre>
       * A trip that is running with no schedule associated to it, for example, if
       * there is no schedule at all.
       * </pre>
       *
       * <code>UNSCHEDULED = 2;</code>
       */
      UNSCHEDULED(2),
      /**
       * <pre>
       * A trip that existed in the schedule but was removed.
       * </pre>
       *
       * <code>CANCELED = 3;</code>
       */
      CANCELED(3),
      ;

      /**
       * <pre>
       * Trip that is running in accordance with its GTFS schedule, or is close
       * enough to the scheduled trip to be associated with it.
       * </pre>
       *
       * <code>SCHEDULED = 0;</code>
       */
      public static final int SCHEDULED_VALUE = 0;
      /**
       * <pre>
       * An extra trip that was added in addition to a running schedule, for
       * example, to replace a broken vehicle or to respond to sudden passenger
       * load.
       * </pre>
       *
       * <code>ADDED = 1;</code>
       */
      public static final int ADDED_VALUE = 1;
      /**
       * <pre>
       * A trip that is running with no schedule associated to it, for example, if
       * there is no schedule at all.
       * </pre>
       *
       * <code>UNSCHEDULED = 2;</code>
       */
      public static final int UNSCHEDULED_VALUE = 2;
      /**
       * <pre>
       * A trip that existed in the schedule but was removed.
       * </pre>
       *
       * <code>CANCELED = 3;</code>
       */
      public static final int CANCELED_VALUE = 3;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ScheduleRelationship valueOf(int value) {
        return forNumber(value);
      }

      public static ScheduleRelationship forNumber(int value) {
        switch (value) {
          case 0: return SCHEDULED;
          case 1: return ADDED;
          case 2: return UNSCHEDULED;
          case 3: return CANCELED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>
      internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
              ScheduleRelationship> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<ScheduleRelationship>() {
                public ScheduleRelationship findValueByNumber(int number) {
                  return ScheduleRelationship.forNumber(number);
                }
              };

      private final int value;

      private ScheduleRelationship(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:transit_realtime.TripDescriptor.ScheduleRelationship)
    }

    private int bitField0_;
    public static final int TRIP_ID_FIELD_NUMBER = 1;
    private java.lang.String tripId_;
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    public boolean hasTripId() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    public java.lang.String getTripId() {
      return tripId_;
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    public com.google.protobuf.ByteString
    getTripIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(tripId_);
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    private void setTripId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      tripId_ = value;
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    private void clearTripId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tripId_ = getDefaultInstance().getTripId();
    }
    /**
     * <pre>
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     * </pre>
     *
     * <code>optional string trip_id = 1;</code>
     */
    private void setTripIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      tripId_ = value.toStringUtf8();
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 5;
    private java.lang.String routeId_;
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    public boolean hasRouteId() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    public java.lang.String getRouteId() {
      return routeId_;
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    public com.google.protobuf.ByteString
    getRouteIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(routeId_);
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    private void setRouteId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      routeId_ = value;
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    private void clearRouteId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      routeId_ = getDefaultInstance().getRouteId();
    }
    /**
     * <pre>
     * The route_id from the GTFS that this selector refers to.
     * </pre>
     *
     * <code>optional string route_id = 5;</code>
     */
    private void setRouteIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      routeId_ = value.toStringUtf8();
    }

    public static final int DIRECTION_ID_FIELD_NUMBER = 6;
    private int directionId_;
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    public boolean hasDirectionId() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    public int getDirectionId() {
      return directionId_;
    }
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    private void setDirectionId(int value) {
      bitField0_ |= 0x00000004;
      directionId_ = value;
    }
    /**
     * <pre>
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     * </pre>
     *
     * <code>optional uint32 direction_id = 6;</code>
     */
    private void clearDirectionId() {
      bitField0_ = (bitField0_ & ~0x00000004);
      directionId_ = 0;
    }

    public static final int START_TIME_FIELD_NUMBER = 2;
    private java.lang.String startTime_;
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    public boolean hasStartTime() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    public java.lang.String getStartTime() {
      return startTime_;
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    public com.google.protobuf.ByteString
    getStartTimeBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(startTime_);
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    private void setStartTime(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000008;
      startTime_ = value;
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    private void clearStartTime() {
      bitField0_ = (bitField0_ & ~0x00000008);
      startTime_ = getDefaultInstance().getStartTime();
    }
    /**
     * <pre>
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     * </pre>
     *
     * <code>optional string start_time = 2;</code>
     */
    private void setStartTimeBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000008;
      startTime_ = value.toStringUtf8();
    }

    public static final int START_DATE_FIELD_NUMBER = 3;
    private java.lang.String startDate_;
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    public boolean hasStartDate() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    public java.lang.String getStartDate() {
      return startDate_;
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    public com.google.protobuf.ByteString
    getStartDateBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(startDate_);
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    private void setStartDate(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      startDate_ = value;
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    private void clearStartDate() {
      bitField0_ = (bitField0_ & ~0x00000010);
      startDate_ = getDefaultInstance().getStartDate();
    }
    /**
     * <pre>
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     * </pre>
     *
     * <code>optional string start_date = 3;</code>
     */
    private void setStartDateBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      startDate_ = value.toStringUtf8();
    }

    public static final int SCHEDULE_RELATIONSHIP_FIELD_NUMBER = 4;
    private int scheduleRelationship_;
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    public boolean hasScheduleRelationship() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship() {
      com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship result = com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.forNumber(scheduleRelationship_);
      return result == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.SCHEDULED : result;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    private void setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000020;
      scheduleRelationship_ = value.getNumber();
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
     */
    private void clearScheduleRelationship() {
      bitField0_ = (bitField0_ & ~0x00000020);
      scheduleRelationship_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TripDescriptor, com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getTripId());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeString(2, getStartTime());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeString(3, getStartDate());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeEnum(4, scheduleRelationship_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeString(5, getRouteId());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(6, directionId_);
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(1, getTripId());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(2, getStartTime());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(3, getStartDate());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
                .computeEnumSize(4, scheduleRelationship_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(5, getRouteId());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeUInt32Size(6, directionId_);
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TripDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A descriptor that identifies an instance of a GTFS trip, or all instances of
     * a trip along a route.
     * - To specify a single trip instance, the trip_id (and if necessary,
     *   start_time) is set. If route_id is also set, then it should be same as one
     *   that the given trip corresponds to.
     * - To specify all the trips along a given route, only the route_id should be
     *   set. Note that if the trip_id is not known, then stop sequence ids in
     *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
     *   addition, absolute arrival/departure times must be provided.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TripDescriptor}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.TripDescriptor, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.TripDescriptor)
            com.google.transit.realtime.GtfsRealtime.TripDescriptorOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.TripDescriptor.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public boolean hasTripId() {
        return instance.hasTripId();
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public java.lang.String getTripId() {
        return instance.getTripId();
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public com.google.protobuf.ByteString
      getTripIdBytes() {
        return instance.getTripIdBytes();
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public Builder setTripId(
              java.lang.String value) {
        copyOnWrite();
        instance.setTripId(value);
        return this;
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public Builder clearTripId() {
        copyOnWrite();
        instance.clearTripId();
        return this;
      }
      /**
       * <pre>
       * The trip_id from the GTFS feed that this selector refers to.
       * For non frequency-based trips, this field is enough to uniquely identify
       * the trip. For frequency-based trip, start_time and start_date might also be
       * necessary.
       * </pre>
       *
       * <code>optional string trip_id = 1;</code>
       */
      public Builder setTripIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTripIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public boolean hasRouteId() {
        return instance.hasRouteId();
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public java.lang.String getRouteId() {
        return instance.getRouteId();
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public com.google.protobuf.ByteString
      getRouteIdBytes() {
        return instance.getRouteIdBytes();
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public Builder setRouteId(
              java.lang.String value) {
        copyOnWrite();
        instance.setRouteId(value);
        return this;
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public Builder clearRouteId() {
        copyOnWrite();
        instance.clearRouteId();
        return this;
      }
      /**
       * <pre>
       * The route_id from the GTFS that this selector refers to.
       * </pre>
       *
       * <code>optional string route_id = 5;</code>
       */
      public Builder setRouteIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRouteIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to. This field is
       * still experimental, and subject to change. It may be formally adopted in
       * the future.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       */
      public boolean hasDirectionId() {
        return instance.hasDirectionId();
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to. This field is
       * still experimental, and subject to change. It may be formally adopted in
       * the future.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       */
      public int getDirectionId() {
        return instance.getDirectionId();
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to. This field is
       * still experimental, and subject to change. It may be formally adopted in
       * the future.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       */
      public Builder setDirectionId(int value) {
        copyOnWrite();
        instance.setDirectionId(value);
        return this;
      }
      /**
       * <pre>
       * The direction_id from the GTFS feed trips.txt file, indicating the
       * direction of travel for trips this selector refers to. This field is
       * still experimental, and subject to change. It may be formally adopted in
       * the future.
       * </pre>
       *
       * <code>optional uint32 direction_id = 6;</code>
       */
      public Builder clearDirectionId() {
        copyOnWrite();
        instance.clearDirectionId();
        return this;
      }

      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public boolean hasStartTime() {
        return instance.hasStartTime();
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public java.lang.String getStartTime() {
        return instance.getStartTime();
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public com.google.protobuf.ByteString
      getStartTimeBytes() {
        return instance.getStartTimeBytes();
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public Builder setStartTime(
              java.lang.String value) {
        copyOnWrite();
        instance.setStartTime(value);
        return this;
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public Builder clearStartTime() {
        copyOnWrite();
        instance.clearStartTime();
        return this;
      }
      /**
       * <pre>
       * The initially scheduled start time of this trip instance.
       * When the trip_id corresponds to a non-frequency-based trip, this field
       * should either be omitted or be equal to the value in the GTFS feed. When
       * the trip_id correponds to a frequency-based trip, the start_time must be
       * specified for trip updates and vehicle positions. If the trip corresponds
       * to exact_times=1 GTFS record, then start_time must be some multiple
       * (including zero) of headway_secs later than frequencies.txt start_time for
       * the corresponding time period. If the trip corresponds to exact_times=0,
       * then its start_time may be arbitrary, and is initially expected to be the
       * first departure of the trip. Once established, the start_time of this
       * frequency-based trip should be considered immutable, even if the first
       * departure time changes -- that time change may instead be reflected in a
       * StopTimeUpdate.
       * Format and semantics of the field is same as that of
       * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
       * </pre>
       *
       * <code>optional string start_time = 2;</code>
       */
      public Builder setStartTimeBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStartTimeBytes(value);
        return this;
      }

      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public boolean hasStartDate() {
        return instance.hasStartDate();
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public java.lang.String getStartDate() {
        return instance.getStartDate();
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public com.google.protobuf.ByteString
      getStartDateBytes() {
        return instance.getStartDateBytes();
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public Builder setStartDate(
              java.lang.String value) {
        copyOnWrite();
        instance.setStartDate(value);
        return this;
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public Builder clearStartDate() {
        copyOnWrite();
        instance.clearStartDate();
        return this;
      }
      /**
       * <pre>
       * The scheduled start date of this trip instance.
       * Must be provided to disambiguate trips that are so late as to collide with
       * a scheduled trip on a next day. For example, for a train that departs 8:00
       * and 20:00 every day, and is 12 hours late, there would be two distinct
       * trips on the same time.
       * This field can be provided but is not mandatory for schedules in which such
       * collisions are impossible - for example, a service running on hourly
       * schedule where a vehicle that is one hour late is not considered to be
       * related to schedule anymore.
       * In YYYYMMDD format.
       * </pre>
       *
       * <code>optional string start_date = 3;</code>
       */
      public Builder setStartDateBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStartDateBytes(value);
        return this;
      }

      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       */
      public boolean hasScheduleRelationship() {
        return instance.hasScheduleRelationship();
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship getScheduleRelationship() {
        return instance.getScheduleRelationship();
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       */
      public Builder setScheduleRelationship(com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship value) {
        copyOnWrite();
        instance.setScheduleRelationship(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;</code>
       */
      public Builder clearScheduleRelationship() {
        copyOnWrite();
        instance.clearScheduleRelationship();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TripDescriptor)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.TripDescriptor();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.TripDescriptor other = (com.google.transit.realtime.GtfsRealtime.TripDescriptor) arg1;
          tripId_ = visitor.visitString(
                  hasTripId(), tripId_,
                  other.hasTripId(), other.tripId_);
          routeId_ = visitor.visitString(
                  hasRouteId(), routeId_,
                  other.hasRouteId(), other.routeId_);
          directionId_ = visitor.visitInt(
                  hasDirectionId(), directionId_,
                  other.hasDirectionId(), other.directionId_);
          startTime_ = visitor.visitString(
                  hasStartTime(), startTime_,
                  other.hasStartTime(), other.startTime_);
          startDate_ = visitor.visitString(
                  hasStartDate(), startDate_,
                  other.hasStartDate(), other.startDate_);
          scheduleRelationship_ = visitor.visitInt(hasScheduleRelationship(), scheduleRelationship_,
                  other.hasScheduleRelationship(), other.scheduleRelationship_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  tripId_ = s;
                  break;
                }
                case 18: {
                  String s = input.readString();
                  bitField0_ |= 0x00000008;
                  startTime_ = s;
                  break;
                }
                case 26: {
                  String s = input.readString();
                  bitField0_ |= 0x00000010;
                  startDate_ = s;
                  break;
                }
                case 32: {
                  int rawValue = input.readEnum();
                  com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship value = com.google.transit.realtime.GtfsRealtime.TripDescriptor.ScheduleRelationship.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(4, rawValue);
                  } else {
                    bitField0_ |= 0x00000020;
                    scheduleRelationship_ = rawValue;
                  }
                  break;
                }
                case 42: {
                  String s = input.readString();
                  bitField0_ |= 0x00000002;
                  routeId_ = s;
                  break;
                }
                case 48: {
                  bitField0_ |= 0x00000004;
                  directionId_ = input.readUInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TripDescriptor.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
    private static final com.google.transit.realtime.GtfsRealtime.TripDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new TripDescriptor();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.TripDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TripDescriptor> PARSER;

    public static com.google.protobuf.Parser<TripDescriptor> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VehicleDescriptorOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.VehicleDescriptor)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  VehicleDescriptor, VehicleDescriptor.Builder> {

    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    boolean hasId();
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    java.lang.String getId();
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    com.google.protobuf.ByteString
    getIdBytes();

    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    boolean hasLabel();
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    java.lang.String getLabel();
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    com.google.protobuf.ByteString
    getLabelBytes();

    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    boolean hasLicensePlate();
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    java.lang.String getLicensePlate();
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    com.google.protobuf.ByteString
    getLicensePlateBytes();
  }
  /**
   * <pre>
   * Identification information for the vehicle performing the trip.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.VehicleDescriptor}
   */
  public  static final class VehicleDescriptor extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  VehicleDescriptor, VehicleDescriptor.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.VehicleDescriptor)
          VehicleDescriptorOrBuilder {
    private VehicleDescriptor() {
      id_ = "";
      label_ = "";
      licensePlate_ = "";
    }
    private int bitField0_;
    public static final int ID_FIELD_NUMBER = 1;
    private java.lang.String id_;
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    public java.lang.String getId() {
      return id_;
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    public com.google.protobuf.ByteString
    getIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(id_);
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void setId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      id_ = value;
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void clearId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      id_ = getDefaultInstance().getId();
    }
    /**
     * <pre>
     * Internal system identification of the vehicle. Should be unique per
     * vehicle, and can be used for tracking the vehicle as it proceeds through
     * the system.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void setIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      id_ = value.toStringUtf8();
    }

    public static final int LABEL_FIELD_NUMBER = 2;
    private java.lang.String label_;
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    public boolean hasLabel() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    public java.lang.String getLabel() {
      return label_;
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    public com.google.protobuf.ByteString
    getLabelBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(label_);
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    private void setLabel(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      label_ = value;
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    private void clearLabel() {
      bitField0_ = (bitField0_ & ~0x00000002);
      label_ = getDefaultInstance().getLabel();
    }
    /**
     * <pre>
     * User visible label, i.e., something that must be shown to the passenger to
     * help identify the correct vehicle.
     * </pre>
     *
     * <code>optional string label = 2;</code>
     */
    private void setLabelBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      label_ = value.toStringUtf8();
    }

    public static final int LICENSE_PLATE_FIELD_NUMBER = 3;
    private java.lang.String licensePlate_;
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    public boolean hasLicensePlate() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    public java.lang.String getLicensePlate() {
      return licensePlate_;
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    public com.google.protobuf.ByteString
    getLicensePlateBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(licensePlate_);
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    private void setLicensePlate(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000004;
      licensePlate_ = value;
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    private void clearLicensePlate() {
      bitField0_ = (bitField0_ & ~0x00000004);
      licensePlate_ = getDefaultInstance().getLicensePlate();
    }
    /**
     * <pre>
     * The license plate of the vehicle.
     * </pre>
     *
     * <code>optional string license_plate = 3;</code>
     */
    private void setLicensePlateBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000004;
      licensePlate_ = value.toStringUtf8();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeString(2, getLabel());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeString(3, getLicensePlate());
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(1, getId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(2, getLabel());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(3, getLicensePlate());
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.VehicleDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Identification information for the vehicle performing the trip.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.VehicleDescriptor}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.VehicleDescriptor, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.VehicleDescriptor)
            com.google.transit.realtime.GtfsRealtime.VehicleDescriptorOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public boolean hasId() {
        return instance.hasId();
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public java.lang.String getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public com.google.protobuf.ByteString
      getIdBytes() {
        return instance.getIdBytes();
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder setId(
              java.lang.String value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }
      /**
       * <pre>
       * Internal system identification of the vehicle. Should be unique per
       * vehicle, and can be used for tracking the vehicle as it proceeds through
       * the system.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder setIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public boolean hasLabel() {
        return instance.hasLabel();
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public java.lang.String getLabel() {
        return instance.getLabel();
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public com.google.protobuf.ByteString
      getLabelBytes() {
        return instance.getLabelBytes();
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public Builder setLabel(
              java.lang.String value) {
        copyOnWrite();
        instance.setLabel(value);
        return this;
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public Builder clearLabel() {
        copyOnWrite();
        instance.clearLabel();
        return this;
      }
      /**
       * <pre>
       * User visible label, i.e., something that must be shown to the passenger to
       * help identify the correct vehicle.
       * </pre>
       *
       * <code>optional string label = 2;</code>
       */
      public Builder setLabelBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLabelBytes(value);
        return this;
      }

      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public boolean hasLicensePlate() {
        return instance.hasLicensePlate();
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public java.lang.String getLicensePlate() {
        return instance.getLicensePlate();
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public com.google.protobuf.ByteString
      getLicensePlateBytes() {
        return instance.getLicensePlateBytes();
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public Builder setLicensePlate(
              java.lang.String value) {
        copyOnWrite();
        instance.setLicensePlate(value);
        return this;
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public Builder clearLicensePlate() {
        copyOnWrite();
        instance.clearLicensePlate();
        return this;
      }
      /**
       * <pre>
       * The license plate of the vehicle.
       * </pre>
       *
       * <code>optional string license_plate = 3;</code>
       */
      public Builder setLicensePlateBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setLicensePlateBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.VehicleDescriptor)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.VehicleDescriptor();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.VehicleDescriptor other = (com.google.transit.realtime.GtfsRealtime.VehicleDescriptor) arg1;
          id_ = visitor.visitString(
                  hasId(), id_,
                  other.hasId(), other.id_);
          label_ = visitor.visitString(
                  hasLabel(), label_,
                  other.hasLabel(), other.label_);
          licensePlate_ = visitor.visitString(
                  hasLicensePlate(), licensePlate_,
                  other.hasLicensePlate(), other.licensePlate_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  id_ = s;
                  break;
                }
                case 18: {
                  String s = input.readString();
                  bitField0_ |= 0x00000002;
                  label_ = s;
                  break;
                }
                case 26: {
                  String s = input.readString();
                  bitField0_ |= 0x00000004;
                  licensePlate_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.VehicleDescriptor.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
    private static final com.google.transit.realtime.GtfsRealtime.VehicleDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new VehicleDescriptor();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.VehicleDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VehicleDescriptor> PARSER;

    public static com.google.protobuf.Parser<VehicleDescriptor> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EntitySelectorOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.EntitySelector)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  EntitySelector, EntitySelector.Builder> {

    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    boolean hasAgencyId();
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    java.lang.String getAgencyId();
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    com.google.protobuf.ByteString
    getAgencyIdBytes();

    /**
     * <code>optional string route_id = 2;</code>
     */
    boolean hasRouteId();
    /**
     * <code>optional string route_id = 2;</code>
     */
    java.lang.String getRouteId();
    /**
     * <code>optional string route_id = 2;</code>
     */
    com.google.protobuf.ByteString
    getRouteIdBytes();

    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    boolean hasRouteType();
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    int getRouteType();

    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    boolean hasTrip();
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip();

    /**
     * <code>optional string stop_id = 5;</code>
     */
    boolean hasStopId();
    /**
     * <code>optional string stop_id = 5;</code>
     */
    java.lang.String getStopId();
    /**
     * <code>optional string stop_id = 5;</code>
     */
    com.google.protobuf.ByteString
    getStopIdBytes();
  }
  /**
   * <pre>
   * A selector for an entity in a GTFS feed.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.EntitySelector}
   */
  public  static final class EntitySelector extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  EntitySelector, EntitySelector.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.EntitySelector)
          EntitySelectorOrBuilder {
    private EntitySelector() {
      agencyId_ = "";
      routeId_ = "";
      stopId_ = "";
    }
    private int bitField0_;
    public static final int AGENCY_ID_FIELD_NUMBER = 1;
    private java.lang.String agencyId_;
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    public boolean hasAgencyId() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    public java.lang.String getAgencyId() {
      return agencyId_;
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    public com.google.protobuf.ByteString
    getAgencyIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(agencyId_);
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    private void setAgencyId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      agencyId_ = value;
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    private void clearAgencyId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      agencyId_ = getDefaultInstance().getAgencyId();
    }
    /**
     * <pre>
     * The values of the fields should correspond to the appropriate fields in the
     * GTFS feed.
     * At least one specifier must be given. If several are given, then the
     * matching has to apply to all the given specifiers.
     * </pre>
     *
     * <code>optional string agency_id = 1;</code>
     */
    private void setAgencyIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      agencyId_ = value.toStringUtf8();
    }

    public static final int ROUTE_ID_FIELD_NUMBER = 2;
    private java.lang.String routeId_;
    /**
     * <code>optional string route_id = 2;</code>
     */
    public boolean hasRouteId() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string route_id = 2;</code>
     */
    public java.lang.String getRouteId() {
      return routeId_;
    }
    /**
     * <code>optional string route_id = 2;</code>
     */
    public com.google.protobuf.ByteString
    getRouteIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(routeId_);
    }
    /**
     * <code>optional string route_id = 2;</code>
     */
    private void setRouteId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      routeId_ = value;
    }
    /**
     * <code>optional string route_id = 2;</code>
     */
    private void clearRouteId() {
      bitField0_ = (bitField0_ & ~0x00000002);
      routeId_ = getDefaultInstance().getRouteId();
    }
    /**
     * <code>optional string route_id = 2;</code>
     */
    private void setRouteIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000002;
      routeId_ = value.toStringUtf8();
    }

    public static final int ROUTE_TYPE_FIELD_NUMBER = 3;
    private int routeType_;
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    public boolean hasRouteType() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    public int getRouteType() {
      return routeType_;
    }
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    private void setRouteType(int value) {
      bitField0_ |= 0x00000004;
      routeType_ = value;
    }
    /**
     * <pre>
     * corresponds to route_type in GTFS.
     * </pre>
     *
     * <code>optional int32 route_type = 3;</code>
     */
    private void clearRouteType() {
      bitField0_ = (bitField0_ & ~0x00000004);
      routeType_ = 0;
    }

    public static final int TRIP_FIELD_NUMBER = 4;
    private com.google.transit.realtime.GtfsRealtime.TripDescriptor trip_;
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    public boolean hasTrip() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
      return trip_ == null ? com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance() : trip_;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    private void setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (value == null) {
        throw new NullPointerException();
      }
      trip_ = value;
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    private void setTrip(
            com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
      trip_ = builderForValue.build();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    private void mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
      if (trip_ != null &&
              trip_ != com.google.transit.realtime.GtfsRealtime.TripDescriptor.getDefaultInstance()) {
        trip_ =
                com.google.transit.realtime.GtfsRealtime.TripDescriptor.newBuilder(trip_).mergeFrom(value).buildPartial();
      } else {
        trip_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
     */
    private void clearTrip() {  trip_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int STOP_ID_FIELD_NUMBER = 5;
    private java.lang.String stopId_;
    /**
     * <code>optional string stop_id = 5;</code>
     */
    public boolean hasStopId() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional string stop_id = 5;</code>
     */
    public java.lang.String getStopId() {
      return stopId_;
    }
    /**
     * <code>optional string stop_id = 5;</code>
     */
    public com.google.protobuf.ByteString
    getStopIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(stopId_);
    }
    /**
     * <code>optional string stop_id = 5;</code>
     */
    private void setStopId(
            java.lang.String value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      stopId_ = value;
    }
    /**
     * <code>optional string stop_id = 5;</code>
     */
    private void clearStopId() {
      bitField0_ = (bitField0_ & ~0x00000010);
      stopId_ = getDefaultInstance().getStopId();
    }
    /**
     * <code>optional string stop_id = 5;</code>
     */
    private void setStopIdBytes(
            com.google.protobuf.ByteString value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000010;
      stopId_ = value.toStringUtf8();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.EntitySelector, com.google.transit.realtime.GtfsRealtime.EntitySelector.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeString(1, getAgencyId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeString(2, getRouteId());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, routeType_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, getTrip());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeString(5, getStopId());
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(1, getAgencyId());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(2, getRouteId());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
                .computeInt32Size(3, routeType_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(4, getTrip());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
                .computeStringSize(5, getStopId());
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.EntitySelector parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.EntitySelector prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A selector for an entity in a GTFS feed.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.EntitySelector}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.EntitySelector, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.EntitySelector)
            com.google.transit.realtime.GtfsRealtime.EntitySelectorOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.EntitySelector.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public boolean hasAgencyId() {
        return instance.hasAgencyId();
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public java.lang.String getAgencyId() {
        return instance.getAgencyId();
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public com.google.protobuf.ByteString
      getAgencyIdBytes() {
        return instance.getAgencyIdBytes();
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public Builder setAgencyId(
              java.lang.String value) {
        copyOnWrite();
        instance.setAgencyId(value);
        return this;
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public Builder clearAgencyId() {
        copyOnWrite();
        instance.clearAgencyId();
        return this;
      }
      /**
       * <pre>
       * The values of the fields should correspond to the appropriate fields in the
       * GTFS feed.
       * At least one specifier must be given. If several are given, then the
       * matching has to apply to all the given specifiers.
       * </pre>
       *
       * <code>optional string agency_id = 1;</code>
       */
      public Builder setAgencyIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setAgencyIdBytes(value);
        return this;
      }

      /**
       * <code>optional string route_id = 2;</code>
       */
      public boolean hasRouteId() {
        return instance.hasRouteId();
      }
      /**
       * <code>optional string route_id = 2;</code>
       */
      public java.lang.String getRouteId() {
        return instance.getRouteId();
      }
      /**
       * <code>optional string route_id = 2;</code>
       */
      public com.google.protobuf.ByteString
      getRouteIdBytes() {
        return instance.getRouteIdBytes();
      }
      /**
       * <code>optional string route_id = 2;</code>
       */
      public Builder setRouteId(
              java.lang.String value) {
        copyOnWrite();
        instance.setRouteId(value);
        return this;
      }
      /**
       * <code>optional string route_id = 2;</code>
       */
      public Builder clearRouteId() {
        copyOnWrite();
        instance.clearRouteId();
        return this;
      }
      /**
       * <code>optional string route_id = 2;</code>
       */
      public Builder setRouteIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRouteIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       */
      public boolean hasRouteType() {
        return instance.hasRouteType();
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       */
      public int getRouteType() {
        return instance.getRouteType();
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       */
      public Builder setRouteType(int value) {
        copyOnWrite();
        instance.setRouteType(value);
        return this;
      }
      /**
       * <pre>
       * corresponds to route_type in GTFS.
       * </pre>
       *
       * <code>optional int32 route_type = 3;</code>
       */
      public Builder clearRouteType() {
        copyOnWrite();
        instance.clearRouteType();
        return this;
      }

      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public boolean hasTrip() {
        return instance.hasTrip();
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TripDescriptor getTrip() {
        return instance.getTrip();
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder setTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.setTrip(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder setTrip(
              com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder builderForValue) {
        copyOnWrite();
        instance.setTrip(builderForValue);
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder mergeTrip(com.google.transit.realtime.GtfsRealtime.TripDescriptor value) {
        copyOnWrite();
        instance.mergeTrip(value);
        return this;
      }
      /**
       * <code>optional .transit_realtime.TripDescriptor trip = 4;</code>
       */
      public Builder clearTrip() {  copyOnWrite();
        instance.clearTrip();
        return this;
      }

      /**
       * <code>optional string stop_id = 5;</code>
       */
      public boolean hasStopId() {
        return instance.hasStopId();
      }
      /**
       * <code>optional string stop_id = 5;</code>
       */
      public java.lang.String getStopId() {
        return instance.getStopId();
      }
      /**
       * <code>optional string stop_id = 5;</code>
       */
      public com.google.protobuf.ByteString
      getStopIdBytes() {
        return instance.getStopIdBytes();
      }
      /**
       * <code>optional string stop_id = 5;</code>
       */
      public Builder setStopId(
              java.lang.String value) {
        copyOnWrite();
        instance.setStopId(value);
        return this;
      }
      /**
       * <code>optional string stop_id = 5;</code>
       */
      public Builder clearStopId() {
        copyOnWrite();
        instance.clearStopId();
        return this;
      }
      /**
       * <code>optional string stop_id = 5;</code>
       */
      public Builder setStopIdBytes(
              com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setStopIdBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.EntitySelector)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.EntitySelector();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (hasTrip()) {
            if (!getTrip().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.EntitySelector other = (com.google.transit.realtime.GtfsRealtime.EntitySelector) arg1;
          agencyId_ = visitor.visitString(
                  hasAgencyId(), agencyId_,
                  other.hasAgencyId(), other.agencyId_);
          routeId_ = visitor.visitString(
                  hasRouteId(), routeId_,
                  other.hasRouteId(), other.routeId_);
          routeType_ = visitor.visitInt(
                  hasRouteType(), routeType_,
                  other.hasRouteType(), other.routeType_);
          trip_ = visitor.visitMessage(trip_, other.trip_);
          stopId_ = visitor.visitString(
                  hasStopId(), stopId_,
                  other.hasStopId(), other.stopId_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readString();
                  bitField0_ |= 0x00000001;
                  agencyId_ = s;
                  break;
                }
                case 18: {
                  String s = input.readString();
                  bitField0_ |= 0x00000002;
                  routeId_ = s;
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000004;
                  routeType_ = input.readInt32();
                  break;
                }
                case 34: {
                  com.google.transit.realtime.GtfsRealtime.TripDescriptor.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000008) == 0x00000008)) {
                    subBuilder = trip_.toBuilder();
                  }
                  trip_ = input.readMessage(com.google.transit.realtime.GtfsRealtime.TripDescriptor.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(trip_);
                    trip_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000008;
                  break;
                }
                case 42: {
                  String s = input.readString();
                  bitField0_ |= 0x00000010;
                  stopId_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.EntitySelector.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
    private static final com.google.transit.realtime.GtfsRealtime.EntitySelector DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new EntitySelector();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.EntitySelector getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EntitySelector> PARSER;

    public static com.google.protobuf.Parser<EntitySelector> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface TranslatedStringOrBuilder extends
          // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedString)
          com.google.protobuf.GeneratedMessageLite.
                  ExtendableMessageOrBuilder<
                  TranslatedString, TranslatedString.Builder> {

    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation>
    getTranslationList();
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index);
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    int getTranslationCount();
  }
  /**
   * <pre>
   * An internationalized message containing per-language versions of a snippet of
   * text or a URL.
   * One of the strings from a message will be picked up. The resolution proceeds
   * as follows:
   * 1. If the UI language matches the language code of a translation,
   *    the first matching translation is picked.
   * 2. If a default UI language (e.g., English) matches the language code of a
   *    translation, the first matching translation is picked.
   * 3. If some translation has an unspecified language code, that translation is
   *    picked.
   * </pre>
   *
   * Protobuf type {@code transit_realtime.TranslatedString}
   */
  public  static final class TranslatedString extends
          com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                  TranslatedString, TranslatedString.Builder> implements
          // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedString)
          TranslatedStringOrBuilder {
    private TranslatedString() {
      translation_ = emptyProtobufList();
    }
    public interface TranslationOrBuilder extends
            // @@protoc_insertion_point(interface_extends:transit_realtime.TranslatedString.Translation)
            com.google.protobuf.GeneratedMessageLite.
                    ExtendableMessageOrBuilder<
                    Translation, Translation.Builder> {

      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      boolean hasText();
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      java.lang.String getText();
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      com.google.protobuf.ByteString
      getTextBytes();

      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      boolean hasLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      java.lang.String getLanguage();
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      com.google.protobuf.ByteString
      getLanguageBytes();
    }
    /**
     * Protobuf type {@code transit_realtime.TranslatedString.Translation}
     */
    public  static final class Translation extends
            com.google.protobuf.GeneratedMessageLite.ExtendableMessage<
                    Translation, Translation.Builder> implements
            // @@protoc_insertion_point(message_implements:transit_realtime.TranslatedString.Translation)
            TranslationOrBuilder {
      private Translation() {
        text_ = "";
        language_ = "";
      }
      private int bitField0_;
      public static final int TEXT_FIELD_NUMBER = 1;
      private java.lang.String text_;
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      public boolean hasText() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      public java.lang.String getText() {
        return text_;
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      public com.google.protobuf.ByteString
      getTextBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(text_);
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      private void setText(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        text_ = value;
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      private void clearText() {
        bitField0_ = (bitField0_ & ~0x00000001);
        text_ = getDefaultInstance().getText();
      }
      /**
       * <pre>
       * A UTF-8 string containing the message.
       * </pre>
       *
       * <code>required string text = 1;</code>
       */
      private void setTextBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        text_ = value.toStringUtf8();
      }

      public static final int LANGUAGE_FIELD_NUMBER = 2;
      private java.lang.String language_;
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      public boolean hasLanguage() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      public java.lang.String getLanguage() {
        return language_;
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      public com.google.protobuf.ByteString
      getLanguageBytes() {
        return com.google.protobuf.ByteString.copyFromUtf8(language_);
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      private void setLanguage(
              java.lang.String value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        language_ = value;
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      private void clearLanguage() {
        bitField0_ = (bitField0_ & ~0x00000002);
        language_ = getDefaultInstance().getLanguage();
      }
      /**
       * <pre>
       * BCP-47 language code. Can be omitted if the language is unknown or if
       * no i18n is done at all for the feed. At most one translation is
       * allowed to have an unspecified language tag.
       * </pre>
       *
       * <code>optional string language = 2;</code>
       */
      private void setLanguageBytes(
              com.google.protobuf.ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        language_ = value.toStringUtf8();
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
              throws java.io.IOException {
        com.google.protobuf.GeneratedMessageLite
                .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder>
                .ExtensionWriter extensionWriter =
                newExtensionWriter();
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeString(1, getText());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          output.writeString(2, getLanguage());
        }
        extensionWriter.writeUntil(2000, output);
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeStringSize(1, getText());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          size += com.google.protobuf.CodedOutputStream
                  .computeStringSize(2, getLanguage());
        }
        size += extensionsSerializedSize();
        size += unknownFields.getSerializedSize();
        memoizedSerializedSize = size;
        return size;
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(byte[] data)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              byte[] data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, data, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(java.io.InputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseDelimitedFrom(java.io.InputStream input)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              com.google.protobuf.CodedInputStream input)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input);
      }
      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageLite.parseFrom(
                DEFAULT_INSTANCE, input, extensionRegistry);
      }

      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }

      /**
       * Protobuf type {@code transit_realtime.TranslatedString.Translation}
       */
      public static final class Builder extends
              com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                      com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation, Builder> implements
              // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedString.Translation)
              com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder {
        // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.newBuilder()
        private Builder() {
          super(DEFAULT_INSTANCE);
        }


        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public boolean hasText() {
          return instance.hasText();
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public java.lang.String getText() {
          return instance.getText();
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public com.google.protobuf.ByteString
        getTextBytes() {
          return instance.getTextBytes();
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public Builder setText(
                java.lang.String value) {
          copyOnWrite();
          instance.setText(value);
          return this;
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public Builder clearText() {
          copyOnWrite();
          instance.clearText();
          return this;
        }
        /**
         * <pre>
         * A UTF-8 string containing the message.
         * </pre>
         *
         * <code>required string text = 1;</code>
         */
        public Builder setTextBytes(
                com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setTextBytes(value);
          return this;
        }

        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public boolean hasLanguage() {
          return instance.hasLanguage();
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public java.lang.String getLanguage() {
          return instance.getLanguage();
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public com.google.protobuf.ByteString
        getLanguageBytes() {
          return instance.getLanguageBytes();
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public Builder setLanguage(
                java.lang.String value) {
          copyOnWrite();
          instance.setLanguage(value);
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public Builder clearLanguage() {
          copyOnWrite();
          instance.clearLanguage();
          return this;
        }
        /**
         * <pre>
         * BCP-47 language code. Can be omitted if the language is unknown or if
         * no i18n is done at all for the feed. At most one translation is
         * allowed to have an unspecified language tag.
         * </pre>
         *
         * <code>optional string language = 2;</code>
         */
        public Builder setLanguageBytes(
                com.google.protobuf.ByteString value) {
          copyOnWrite();
          instance.setLanguageBytes(value);
          return this;
        }

        // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedString.Translation)
      }
      private byte memoizedIsInitialized = -1;
      protected final Object dynamicMethod(
              com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
              Object arg0, Object arg1) {
        switch (method) {
          case NEW_MUTABLE_INSTANCE: {
            return new com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation();
          }
          case IS_INITIALIZED: {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return DEFAULT_INSTANCE;
            if (isInitialized == 0) return null;

            boolean shouldMemoize = ((Boolean) arg0).booleanValue();
            if (!hasText()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
            if (!extensionsAreInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
            if (shouldMemoize) memoizedIsInitialized = 1;
            return DEFAULT_INSTANCE;

          }
          case MAKE_IMMUTABLE: {
            return null;
          }
          case NEW_BUILDER: {
            return new Builder();
          }
          case VISIT: {
            Visitor visitor = (Visitor) arg0;
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation other = (com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation) arg1;
            text_ = visitor.visitString(
                    hasText(), text_,
                    other.hasText(), other.text_);
            language_ = visitor.visitString(
                    hasLanguage(), language_,
                    other.hasLanguage(), other.language_);
            if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                    .INSTANCE) {
              bitField0_ |= other.bitField0_;
            }
            return this;
          }
          case MERGE_FROM_STREAM: {
            com.google.protobuf.CodedInputStream input =
                    (com.google.protobuf.CodedInputStream) arg0;
            com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                    (com.google.protobuf.ExtensionRegistryLite) arg1;
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  default: {
                    if (!parseUnknownField(getDefaultInstanceForType(),
                            input, extensionRegistry, tag)) {
                      done = true;
                    }
                    break;
                  }
                  case 10: {
                    String s = input.readString();
                    bitField0_ |= 0x00000001;
                    text_ = s;
                    break;
                  }
                  case 18: {
                    String s = input.readString();
                    bitField0_ |= 0x00000002;
                    language_ = s;
                    break;
                  }
                }
              }
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw new RuntimeException(e.setUnfinishedMessage(this));
            } catch (java.io.IOException e) {
              throw new RuntimeException(
                      new com.google.protobuf.InvalidProtocolBufferException(
                              e.getMessage()).setUnfinishedMessage(this));
            } finally {
            }
          }
          case GET_DEFAULT_INSTANCE: {
            return DEFAULT_INSTANCE;
          }
          case GET_PARSER: {
            if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
            }
            return PARSER;
          }
        }
        throw new UnsupportedOperationException();
      }


      // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
      private static final com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Translation();
        DEFAULT_INSTANCE.makeImmutable();
      }

      public static com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static volatile com.google.protobuf.Parser<Translation> PARSER;

      public static com.google.protobuf.Parser<Translation> parser() {
        return DEFAULT_INSTANCE.getParserForType();
      }
    }

    public static final int TRANSLATION_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> translation_;
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> getTranslationList() {
      return translation_;
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    public java.util.List<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder>
    getTranslationOrBuilderList() {
      return translation_;
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    public int getTranslationCount() {
      return translation_.size();
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index) {
      return translation_.get(index);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    public com.google.transit.realtime.GtfsRealtime.TranslatedString.TranslationOrBuilder getTranslationOrBuilder(
            int index) {
      return translation_.get(index);
    }
    private void ensureTranslationIsMutable() {
      if (!translation_.isModifiable()) {
        translation_ =
                com.google.protobuf.GeneratedMessageLite.mutableCopy(translation_);
      }
    }

    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void setTranslation(
            int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureTranslationIsMutable();
      translation_.set(index, value);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void setTranslation(
            int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
      ensureTranslationIsMutable();
      translation_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void addTranslation(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureTranslationIsMutable();
      translation_.add(value);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void addTranslation(
            int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureTranslationIsMutable();
      translation_.add(index, value);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void addTranslation(
            com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
      ensureTranslationIsMutable();
      translation_.add(builderForValue.build());
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void addTranslation(
            int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
      ensureTranslationIsMutable();
      translation_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void addAllTranslation(
            java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> values) {
      ensureTranslationIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
              values, translation_);
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void clearTranslation() {
      translation_ = emptyProtobufList();
    }
    /**
     * <pre>
     * At least one translation must be provided.
     * </pre>
     *
     * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
     */
    private void removeTranslation(int index) {
      ensureTranslationIsMutable();
      translation_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
      com.google.protobuf.GeneratedMessageLite
              .ExtendableMessage<com.google.transit.realtime.GtfsRealtime.TranslatedString, com.google.transit.realtime.GtfsRealtime.TranslatedString.Builder>
              .ExtensionWriter extensionWriter =
              newExtensionWriter();
      for (int i = 0; i < translation_.size(); i++) {
        output.writeMessage(1, translation_.get(i));
      }
      extensionWriter.writeUntil(2000, output);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < translation_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
                .computeMessageSize(1, translation_.get(i));
      }
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(java.io.InputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input);
    }
    public static com.google.transit.realtime.GtfsRealtime.TranslatedString parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
              DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.transit.realtime.GtfsRealtime.TranslatedString prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * An internationalized message containing per-language versions of a snippet of
     * text or a URL.
     * One of the strings from a message will be picked up. The resolution proceeds
     * as follows:
     * 1. If the UI language matches the language code of a translation,
     *    the first matching translation is picked.
     * 2. If a default UI language (e.g., English) matches the language code of a
     *    translation, the first matching translation is picked.
     * 3. If some translation has an unspecified language code, that translation is
     *    picked.
     * </pre>
     *
     * Protobuf type {@code transit_realtime.TranslatedString}
     */
    public static final class Builder extends
            com.google.protobuf.GeneratedMessageLite.ExtendableBuilder<
                    com.google.transit.realtime.GtfsRealtime.TranslatedString, Builder> implements
            // @@protoc_insertion_point(builder_implements:transit_realtime.TranslatedString)
            com.google.transit.realtime.GtfsRealtime.TranslatedStringOrBuilder {
      // Construct using com.google.transit.realtime.GtfsRealtime.TranslatedString.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public java.util.List<com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> getTranslationList() {
        return java.util.Collections.unmodifiableList(
                instance.getTranslationList());
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public int getTranslationCount() {
        return instance.getTranslationCount();
      }/**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation getTranslation(int index) {
        return instance.getTranslation(index);
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder setTranslation(
              int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        copyOnWrite();
        instance.setTranslation(index, value);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder setTranslation(
              int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        copyOnWrite();
        instance.setTranslation(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        copyOnWrite();
        instance.addTranslation(value);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
              int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation value) {
        copyOnWrite();
        instance.addTranslation(index, value);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
              com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        copyOnWrite();
        instance.addTranslation(builderForValue);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addTranslation(
              int index, com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.Builder builderForValue) {
        copyOnWrite();
        instance.addTranslation(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder addAllTranslation(
              java.lang.Iterable<? extends com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation> values) {
        copyOnWrite();
        instance.addAllTranslation(values);
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder clearTranslation() {
        copyOnWrite();
        instance.clearTranslation();
        return this;
      }
      /**
       * <pre>
       * At least one translation must be provided.
       * </pre>
       *
       * <code>repeated .transit_realtime.TranslatedString.Translation translation = 1;</code>
       */
      public Builder removeTranslation(int index) {
        copyOnWrite();
        instance.removeTranslation(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:transit_realtime.TranslatedString)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
            com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
            Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.transit.realtime.GtfsRealtime.TranslatedString();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          for (int i = 0; i < getTranslationCount(); i++) {
            if (!getTranslation(i).isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (!extensionsAreInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          translation_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.transit.realtime.GtfsRealtime.TranslatedString other = (com.google.transit.realtime.GtfsRealtime.TranslatedString) arg1;
          translation_= visitor.visitList(translation_, other.translation_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
                  .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
                  (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
                  (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(getDefaultInstanceForType(),
                          input, extensionRegistry, tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!translation_.isModifiable()) {
                    translation_ =
                            com.google.protobuf.GeneratedMessageLite.mutableCopy(translation_);
                  }
                  translation_.add(
                          input.readMessage(com.google.transit.realtime.GtfsRealtime.TranslatedString.Translation.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                    new com.google.protobuf.InvalidProtocolBufferException(
                            e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.transit.realtime.GtfsRealtime.TranslatedString.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
    private static final com.google.transit.realtime.GtfsRealtime.TranslatedString DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new TranslatedString();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.transit.realtime.GtfsRealtime.TranslatedString getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TranslatedString> PARSER;

    public static com.google.protobuf.Parser<TranslatedString> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
